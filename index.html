<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pure and Infinite Joy Machine</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ù§Ô∏è</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body class="bg-gray-100 text-black min-h-screen p-4">
  <!-- Background Music -->
  <audio id="background-music" preload="auto">
    <!-- Sources will be dynamically added -->
    Your browser does not support the audio element.
  </audio>
  
  <div class="flex flex-col items-center justify-start min-h-screen space-y-6 pt-16">
    <!-- Header -->
    <h1 class="text-2xl font-semibold text-gray-900">Pure and Infinite Joy Machine</h1>

    <!-- Generate Button -->
    <button id="generate-btn" class="font-bold py-2 px-6 rounded-lg text-sm transition-colors duration-300 w-full max-w-md">
      <span class="btn-text"></span>
    </button>

    <!-- Phrase Display Area -->
    <div class="flex flex-col sm:flex-row items-center justify-center w-full max-w-md relative">
      <p id="phrase-output" class="text-xl font-medium text-gray-900 text-center"></p>
      <button id="copy-btn" class="opacity-0 transition-opacity duration-200 p-2 rounded sm:absolute sm:-right-10 mt-2">
        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
        </svg>
      </button>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="text-center text-gray-500 text-lg opacity-0 transition-opacity duration-100 pointer-events-none">
      copied
    </div>

    <!-- Format Display -->
    <!-- <div id="format-display" class="text-center text-gray-400 text-xs mt-2"></div> -->
  </div>

  <!-- Control Buttons -->
  <div class="fixed bottom-4 left-4 flex items-center space-x-2 z-10">
    <!-- Mute Button -->
    <button id="mute-btn" class="w-8 h-8 flex items-center justify-center">
      <img id="mute-icon" src="images/volume.png" alt="Volume" class="w-6 h-6 transition-all duration-300">
    </button>
    
    <!-- Dark Mode Button -->
    <button id="dark-mode-btn" class="w-8 h-8 flex items-center justify-center">
      <span id="dark-mode-icon" class="text-xl transition-all duration-300">üåô</span>
    </button>
  </div>

  <!-- child's mode Toggle -->
  <div class="fixed bottom-4 right-4 flex items-center space-x-3 z-10">
    <label for="childs-mode-toggle" class="text-sm text-gray-600 cursor-pointer">
      Child's Mode
    </label>
    <button id="childs-mode-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 p-1">
      <span id="childs-mode-slider" class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
    </button>
  </div>

  <!-- Import the word lists -->
  <script src="lists.js"></script>
  
  <script>
    // --- CONFIGURATION ---
    const CONFIG = {
      fillDuration: 50000, // 50 seconds in milliseconds
      updateInterval: 50, // Update every 50ms for smooth animation
      advanceAmount: 0.03, // 3% of total steps when clicked
      typoChance: 0.018, // 1.8% chance per letter
      typoCorrectionChance: .90, // 90% chance to catch typo
      doubleBeastChance: 0.85, // 85% chance for two beasts
      tripleBeastChance: 0.60, // 60% chance for three beasts (if already two)
      doubleCandyChance: .5, // 50% chance for two candies
      fuckingChance: 0.12, // 12% chance to add "fucking"
      thinkingPauseChance: 0.15, // 15% chance for thinking pause
      allCapsChance: 0.10, // 10% chance for all caps (except beast)
      skipSpaceChance: 0.00, // 0% chance to skip spaces between words
      swapLettersChance: 0.008, // .8% chance to swap two adjacent letters in word
      testMode: false, // Test mode - instant progress bar fill
      childsMode: false, // child's mode state
      backgroundMusic: true, // Enable background music
      musicVolume: 0.10, // Background music volume (0.0 to 1.0)
      tagChance: 0.3, // 30% chance for tag after finale/hard stop
      darkMode: false, // Dark mode state
      noConsole: false, // Disable all console logs when true
      typingSpeedMultiplier: .8, // Typing speed multiplier (1.0 = double speed, 0.5 = normal, 0.0 = half speed)
      typingSpeed: { //higher numbers = slower typing
        space: { min: 22, max: 36 },
        vowel: { min: 8, max: 22 },
        consonant: { min: 10, max: 26 },
        number: { min: 45, max: 80 },
        punctuation: { min: 32, max: 70 }
      }
    };

    // --- FORMATS ---
    // Define the possible formats (now using intro + word order)
    // Helper function to join non-empty words with spaces
    const joinWords = (...words) => words.filter(word => word && word.trim() !== '').join(' ');
    
    const formats = [

            (i, b, n, c, a, f) => joinWords(i), 
            (i, b, n, c, a, f) => joinWords(n),
            (i, b, n, c, a, f) => joinWords(c), (i, b, n, c, a, f) => joinWords(c),
            // (i, b, n, c, a, f) => joinWords(f),
            
            // (i, b, n, c, a, f) => joinWords(i, f),
            (i, b, n, c, a, f) => joinWords(a, n), 
            // (i, b, n, c, a, f) => joinWords(a, n), 
            (i, b, n, c, a, f) => joinWords(c, n), 
            // (i, b, n, c, a, f) => joinWords(c, n),
            // (i, b, n, c, a, f) => joinWords(n, f),

            (i, b, n, c, a, f) => joinWords(i, b, f),
            // (i, b, n, c, a, f) => joinWords(i, c, f),
            (i, b, n, c, a, f) => joinWords(i, n, f),
            (i, b, n, c, a, f) => joinWords(i, a, n), 
            // (i, b, n, c, a, f) => joinWords(i, a, n),
            // (i, b, n, c, a, f) => joinWords(b, n, f),
            // (i, b, n, c, a, f) => joinWords(b, c, f),
            // (i, b, n, c, a, f) => joinWords(b, a, n),
            (i, b, n, c, a, f) => joinWords(a, n, f),
            // (i, b, n, c, a, f) => joinWords(c, a, n),
        
            (i, b, n, c, a, f) => joinWords(i, n, c, f),
            // (i, b, n, c, a, f) => joinWords(i, c, b, f),
            (i, b, n, c, a, f) => joinWords(i, c, n, f),
            (i, b, n, c, a, f) => joinWords(i, a, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, c, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, n),
            // (i, b, n, c, a, f) => joinWords(b, a, n, f),
            // (i, b, n, c, a, f) => joinWords(b, c, n, f),
            // (i, b, n, c, a, f) => joinWords(b, a, c, f),

            (i, b, n, c, a, f) => joinWords(i, b, a, c, f),
            // (i, b, n, c, a, f) => joinWords(b, a, c, f, i),
            (i, b, n, c, a, f) => joinWords(i, c, a, n, f),
            (i, b, n, c, a, f) => joinWords(i, a, n, c, f),
            (i, b, n, c, a, f) => joinWords(i, a, c, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, c, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, n, f),
            (i, b, n, c, a, f) => joinWords(b, c, a, n, i),
            // (i, b, n, c, a, f) => joinWords(i, n, a, c, f),
            (i, b, n, c, a, f) => joinWords(i, a, b, c, f),
            (i, b, n, c, a, f) => joinWords(i, a, b, n, f),
            // (i, b, n, c, a, f) => joinWords(c, i, b, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, c, a, n, f),
            (i, b, n, c, a, f) => joinWords(c, i, b, a, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, n, c, f),
            (i, b, n, c, a, f) => joinWords(b, i, c, a, n, f),
            (i, b, n, c, a, f) => joinWords(b, a, n, c, f, i),
            (i, b, n, c, a, f) => joinWords(i, c, b, a, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, c, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, c, n, f)


            ];
        
    

    // Pre-computed QWERTY keyboard layout for typo generation (only horizontally adjacent keys)
    const QWERTY_MAP = {
        'q': ['w'], 'w': ['q', 'e'], 'e': ['w', 'r'],
        'r': ['e', 't'], 't': ['r', 'y'], 'y': ['t', 'u'],
        'u': ['y', 'i'], 'i': ['u', 'o'], 'o': ['i', 'p'],
        'p': ['o'], 'a': ['s'], 's': ['a', 'd'],
        'd': ['s', 'f'], 'f': ['d', 'g'], 'g': ['f', 'h'],
        'h': ['g', 'j'], 'j': ['h', 'k'], 'k': ['j', 'l'],
        'l': ['k'], 'z': ['x'], 'x': ['z', 'c'],
        'c': ['x', 'v'], 'v': ['c', 'b'], 'b': ['v', 'n'],
        'n': ['b', 'm'], 'm': ['n']
    };
    
    // Pre-computed typo lookup for faster access
    const TYPO_CACHE = new Map();
    const getTypoChar = (char) => {
        if (TYPO_CACHE.has(char)) {
            return TYPO_CACHE.get(char);
        }
        
        const adjacent = QWERTY_MAP[char.toLowerCase()];
        if (!adjacent || adjacent.length === 0) {
            TYPO_CACHE.set(char, char);
            return char;
        }
        
        const randomTypo = adjacent[Math.floor(Math.random() * adjacent.length)];
        const result = char === char.toUpperCase() ? randomTypo.toUpperCase() : randomTypo;
        TYPO_CACHE.set(char, result);
        return result;
    };

    // --- DOM ELEMENTS & STATE ---
    const generateBtn = document.getElementById('generate-btn');
    const phraseOutput = document.getElementById('phrase-output');
    const copyBtn = document.getElementById('copy-btn');
    const toast = document.getElementById('toast');
    const childsModeToggle = document.getElementById('childs-mode-toggle');
    const childsModeSlider = document.getElementById('childs-mode-slider');
    let fillInterval;
    let currentFill = 0;
    const totalSteps = CONFIG.fillDuration / CONFIG.updateInterval; // Total number of steps
    let isComplete = false;
    let pageTurnPlayed = false;
    let typingTimeouts = []; // Track active typing timeouts to prevent conflicts
    let isTyping = false; // Track if typing animation is currently active
    
    // Item timeout system - track recently used items to prevent repetition
    let itemTimeouts = {
        intro: new Map(), // Map of item -> remaining timeout count
        beast: new Map(),
        noun: new Map(),
        candy: new Map(),
        adjective: new Map(),
        finale: new Map(),
        tag: new Map()
    };

    // --- FUNCTIONS ---
    /**
     * Clears all active typing timeouts to prevent conflicts
     */
    const clearTypingTimeouts = () => {
      typingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
      typingTimeouts = [];
      isTyping = false;
    };

    /**
     * Adds an item to the timeout list with dynamic cooldown based on list size
     */
    const addItemToTimeout = (listType, item) => {
      const listTypes = ['intro', 'beast', 'noun', 'candy', 'adjective', 'finale', 'tag'];
      const listIndex = listTypes.indexOf(listType);
      
      if (listIndex !== -1 && window.wordLists && window.wordLists[listIndex]) {
        // Cooldown = total items in list - 1 (so it cycles through all items before repeating)
        const cooldownDuration = window.wordLists[listIndex].length - 1;
        itemTimeouts[listType].set(item, cooldownDuration);
      } else {
        // Fallback to a default if something goes wrong
        itemTimeouts[listType].set(item, 25);
      }
    };

    /**
     * Decrements all timeout counters and removes expired items
     */
    const decrementTimeouts = () => {
      Object.keys(itemTimeouts).forEach(listType => {
        const timeoutMap = itemTimeouts[listType];
        const itemsToRemove = [];
        
        timeoutMap.forEach((count, item) => {
          const newCount = count - 1;
          if (newCount <= 0) {
            itemsToRemove.push(item);
          } else {
            timeoutMap.set(item, newCount);
          }
        });
        
        itemsToRemove.forEach(item => timeoutMap.delete(item));
      });
    };

    /**
     * Gets available items from a list, excluding those on timeout
     */
    const getAvailableItems = (listIndex) => {
      const listTypes = ['intro', 'beast', 'noun', 'candy', 'adjective', 'finale', 'tag'];
      const listType = listTypes[listIndex];
      const allItems = window.wordLists[listIndex];
      const timeoutMap = itemTimeouts[listType];
      
      // Filter out items that are on timeout
      const availableItems = allItems.filter(item => !timeoutMap.has(item));
      
      // If all items are on timeout (shouldn't happen with 10 timeout and variety)
      return availableItems.length > 0 ? availableItems : allItems;
    };

    /**
     * Applies letter swapping chaos to a phrase (per-word basis with length-based probability)
     * Returns both the processed phrase and a set of words that were letter-swapped
     */
    const applyLetterSwapping = (phrase) => {
      // Split phrase into words
      const words = phrase.split(' ');
      const swappedWords = new Set(); // Track which words were letter-swapped
      
      // Process each word individually
      const processedWords = words.map(word => {
        // Skip words that contain numbers or non-letter characters (only a-z eligible)
        if (/\d/.test(word) || /[^a-zA-Z]/.test(word)) {
          return word;
        }
        
        // Need at least 3 characters to swap (first and last are immune)
        if (word.length < 3) {
          return word; // Not enough letters to swap
        }
        
        // Calculate probability based on word length
        // Base 1% for 2-4 letter words, +1% for each letter over 4
        const baseChance = CONFIG.swapLettersChance; // 1%
        const lengthBonus = Math.max(0, word.length - 4) * 0.01; // +1% per letter over 4
        const finalChance = baseChance + lengthBonus;
        
        // Check if we should swap letters in this word
        if (Math.random() >= finalChance) {
          return word; // No swapping this word
        }
        
        // Convert word to array for easier manipulation
        const chars = word.split('');
        
        // Find all eligible adjacent pairs (not involving first/last letters)
        const eligiblePairs = [];
        for (let i = 1; i < chars.length - 2; i++) {
          eligiblePairs.push(i); // i and i+1 will be swapped
        }
        
        // Need at least one eligible adjacent pair to swap
        if (eligiblePairs.length === 0) {
          return word; // Not enough letters to swap
        }
        
        // Pick a random adjacent pair to swap
        const pairIndex = eligiblePairs[Math.floor(Math.random() * eligiblePairs.length)];
        const pos1 = pairIndex;
        const pos2 = pairIndex + 1;
        
        // Swap the adjacent characters
        const temp = chars[pos1];
        chars[pos1] = chars[pos2];
        chars[pos2] = temp;
        
        const swappedWord = chars.join('');
        swappedWords.add(swappedWord); // Track this word as letter-swapped
        
        return swappedWord;
      });
      
      return {
        phrase: processedWords.join(' '),
        swappedWords: swappedWords
      };
    };

    /**
     * Generates a random "weeeeee" with 4-10 'e's
     * @returns {string} A random weeeeee string
     */
    const generateWeeeeee = () => {
      const eCount = Math.floor(Math.random() * 7) + 4; // 4-10 'e's
      return 'we' + 'e'.repeat(eCount);
    };

    /**
     * Replaces NSFW words with appropriate alternatives if child's mode is enabled
     * @param {string} text The text to filter
     * @returns {string} The filtered text
     */
    const filterNSFW = (text) => {
      if (!CONFIG.childsMode) return text;
      
      let filteredText = text;
      
      // First pass: Apply custom replacements to specific words
      // Sort by length (longest first) to ensure compound words are processed before their components
      const replacementWords = Object.keys(window.childsModeReplacements)
        .sort((a, b) => b.length - a.length);
      
      replacementWords.forEach(originalWord => {
        const replacement = window.childsModeReplacements[originalWord];
        // Replace the original word with custom replacement
        const regex = new RegExp(`\\b${originalWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
        filteredText = filteredText.replace(regex, replacement);
      });
      
      // Second pass: Replace remaining NSFW words with weeeeee
      // Sort by length (longest first) to ensure compound words are processed before their components
      const sortedNsfwWords = window.nsfwWords
        .filter(word => !window.childsModeReplacements.hasOwnProperty(word.toLowerCase())) // Skip words that have custom replacements
        .sort((a, b) => b.length - a.length);
      
      sortedNsfwWords.forEach(nsfwWord => {
        // Create case-insensitive regex for the word
        const regex = new RegExp(`\\b${nsfwWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
        filteredText = filteredText.replace(regex, generateWeeeeee());
      });
      
      return filteredText;
    };

    /**
     * Selects a random item from a given array and processes brackets.
     * @param {Array} arr The array to pick from.
     * @returns {*} A random item from the array with brackets processed.
     */
    const getRandomItem = (arr) => {
      const rawItem = arr[Math.floor(Math.random() * arr.length)];
      const { result } = processBrackets(rawItem);
      return result;
    };

    /**
     * Creates a word tracking object for detailed format display
     */
    const createWordTracking = (original) => ({
        original,
        final: original,
        modifications: [],
        addons: [],
        alternates: [],
        hardStop: false,
        beastStop: false
    });

    /**
     * Processes alternates in a word (content in parentheses with / separators)
     */
    const processAlternates = (word) => {
        let result = word;
        let alternates = [];
        const alternatesRegex = /\(([^)]*(?:\/[^)]*)+)\)/g;
        let match;
        
        while ((match = alternatesRegex.exec(word)) !== null) {
            const alternatesContent = match[1];
            const options = alternatesContent.split('/').map(opt => opt.trim());
            
            // Check if any option has custom probability
            const hasCustomProbabilities = options.some(opt => opt.includes(',') && /,\s*\d*\.?\d+$/.test(opt));
            
            let selectedOption;
            if (hasCustomProbabilities) {
                // Parse options with probabilities
                const weightedOptions = [];
                options.forEach(opt => {
                    const probMatch = opt.match(/^(.+),\s*(\d*\.?\d+)$/);
                    if (probMatch) {
                        const content = probMatch[1].trim();
                        const weight = parseFloat(probMatch[2]);
                        weightedOptions.push({ content, weight });
                    } else {
                        weightedOptions.push({ content: opt, weight: 1 });
                    }
                });
                
                const totalWeight = weightedOptions.reduce((sum, opt) => sum + opt.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const opt of weightedOptions) {
                    random -= opt.weight;
                    if (random <= 0) {
                        selectedOption = opt.content;
                        break;
                    }
                }
            } else {
                const selectedIndex = Math.floor(Math.random() * options.length);
                selectedOption = options[selectedIndex];
                alternates.push(`alt: ${selectedOption}`);
            }
            
            result = result.replace(match[0], selectedOption);
        }
        
        return { result, alternates };
    };

    /**
     * Processes brackets (add-ons) in a word from innermost to outermost
     */
    const processBrackets = (word) => {
        let result = word;
        let addons = [];
        let hasHardStop = false;
        let hasBeastStop = false;
        
        // Check for *B* at the end of the main word (not in brackets)
        if (result.includes(', *B*') || result.endsWith(' *B*')) {
            hasBeastStop = true;
            // Remove the *B* marker from the result
            result = result.replace(/,\s*\*B\*|\s*\*B\*$/, '');
        }
        
        let changed = true;
        while (changed) {
            changed = false;
            
            // Find the innermost bracket (no brackets inside it)
            const innermostBracketRegex = /\[([^\[\]]+)\]/;
            const bracketMatch = result.match(innermostBracketRegex);
            
            if (bracketMatch) {
                const bracketContent = bracketMatch[1];
                
                
                // Check for custom probability
                const probabilityMatch = bracketContent.match(/^(.+),\s*(\d*\.?\d+)(?:,\s*\*F\*|\*B\*)?$/);
                let probability = 0.5;
                let contentToProcess = bracketContent;
                
                if (probabilityMatch) {
                    contentToProcess = probabilityMatch[1].trim();
                    probability = parseFloat(probabilityMatch[2]);
                } else {
                    // Check if it's just content with *F* or *B* (no probability)
                    const hardStopMatch = bracketContent.match(/^(.+),\s*\*F\*$/);
                    const beastStopMatch = bracketContent.match(/^(.+),\s*\*B\*$/);
                    if (hardStopMatch) {
                        contentToProcess = hardStopMatch[1].trim();
                        probability = 0.5; // default probability
                    } else if (beastStopMatch) {
                        contentToProcess = beastStopMatch[1].trim();
                        probability = 0.5; // default probability
                    }
                }
                
                const shouldInclude = Math.random() < probability;
                
                if (shouldInclude) {
                    // Clean the content before adding it to the result
                    let cleanContent = contentToProcess;
                    
                    // Check for hard stop (*F*) before removing it
                    if (bracketContent.includes('*F*')) {
                        hasHardStop = true;
                    }
                    
                    // Check for beast stop (*B*) before removing it
                    if (bracketContent.includes('*B*')) {
                        hasBeastStop = true;
                    }
                    
                    // Remove hard stop marker (*F*) from the content
                    cleanContent = cleanContent.replace(/\*F\*/g, '');
                    
                    // Remove any remaining probability info that might be in the content
                    cleanContent = cleanContent.replace(/,\s*\d*\.?\d+\s*$/, '');
                    cleanContent = cleanContent.replace(/,\s*\d*\.?\d+\s*,/, ',');
                    
                    result = result.replace(bracketMatch[0], cleanContent);
                    
                    
                    // Track the full bracket content including probability for display
                    addons.push(bracketContent);
                } else {
                    result = result.replace(bracketMatch[0], '');
                    
                }
                
                changed = true;
            }
        }
        
        return { result: result.replace(/\s+/g, ' ').trim(), addons, hasHardStop, hasBeastStop };
    };
    


    /**
     * Cleans up phrase formatting by removing unwanted start/end words
     */
    const cleanPhrase = (phrase) => {
        // Words that shouldn't start a phrase (case insensitive)
        const badStartWords = ['and', 'or', 'for', 'with', 'in', 'by way of', 'using', 'ok', 'plus', 'compilation','emits'];
        
        // Words that shouldn't end a phrase (case insensitive)
        const badEndWords = ['fucking', 'crazy'];
        
        // Check if phrase starts with any of the bad words
        for (const badWord of badStartWords) {
            const regex = new RegExp(`^${badWord}\\s+`, 'i');
            phrase = phrase.replace(regex, '');
        }
        
        // Check if phrase ends with any of the bad words
        for (const badWord of badEndWords) {
            const regex = new RegExp(`\\s+${badWord}$`, 'i');
            phrase = phrase.replace(regex, '');
        }
        
        // Clean up any extra spaces
        phrase = phrase.replace(/^\s+/, '').replace(/\s+$/, '').replace(/\s+/g, ' ');
        
        return phrase;
    };

    /**
     * Adds a tag to a phrase, handling special spacing for tags that start with periods
     */
    const addTagToPhrase = (phrase, tag) => {
        // If tag starts with a period, remove the space before it
        if (tag.startsWith('.')) {
            return `${phrase.trim()}${tag}`;
        }
        // Otherwise, add with normal spacing
        return `${phrase} ${tag}`;
    };

    /**
     * Generates a new phrase and displays it.
     */
    const generateNewPhrase = () => {
        // Hide copy button while generating new phrase
        copyBtn.classList.add('opacity-0');
        
        // Clear any existing typing animations to prevent conflicts
        clearTypingTimeouts();
        
        // Define the possible formats (now using intro + word order)
        // Helper function to join non-empty words with spaces
        const joinWords = (...words) => words.filter(word => word && word.trim() !== '').join(' ');
        
        
    
        
        // Pick a random format
        const randomFormat = formats[Math.floor(Math.random() * formats.length)];
        const formatIndex = formats.indexOf(randomFormat);
        
        // Create a readable format string for logging
        const getFormatString = (format) => {
            const testResult = format('I', 'B', 'N', 'C', 'A', 'F');
            return testResult;
        };
        const formatString = getFormatString(randomFormat);
        
        // Determine which word types are needed for this format
        const needsIntro = formatString.includes('I');
        const needsBeast = formatString.includes('B');
        const needsNoun = formatString.includes('N');
        const needsCandy = formatString.includes('C');
        const needsAdjective = formatString.includes('A');
        const needsFinale = formatString.includes('F');
        
        // Only get random items for the word types we actually need
        const intro = needsIntro ? getAvailableItems(0)[Math.floor(Math.random() * getAvailableItems(0).length)] : null;
        const beast = needsBeast ? getAvailableItems(1)[Math.floor(Math.random() * getAvailableItems(1).length)] : null;
        const noun = needsNoun ? getAvailableItems(2)[Math.floor(Math.random() * getAvailableItems(2).length)] : null;
        const candy = needsCandy ? getAvailableItems(3)[Math.floor(Math.random() * getAvailableItems(3).length)] : null;
        const adjective = needsAdjective ? getAvailableItems(4)[Math.floor(Math.random() * getAvailableItems(4).length)] : null;
        const finale = needsFinale ? getAvailableItems(5)[Math.floor(Math.random() * getAvailableItems(5).length)] : null;
        
        // Track the actual words and their modifications for detailed display (only for needed types)
        const wordTracking = {
            intro: intro ? createWordTracking(intro) : null,
            beast: beast ? createWordTracking(beast) : null,
            noun: noun ? createWordTracking(noun) : null,
            candy: candy ? createWordTracking(candy) : null,
            adjective: adjective ? createWordTracking(adjective) : null,
            finale: finale ? createWordTracking(finale) : null
        };
        
        // Process each word with tracking
        const processWordWithTracking = (word, tracking) => {
            // Process alternates first
            const { result: afterAlternates, alternates } = processAlternates(word);
            
            // Process brackets
            const { result, addons, hasHardStop, hasBeastStop } = processBrackets(afterAlternates);
            
            // Update tracking
            tracking.final = result;
            tracking.addons = addons;
            tracking.alternates = alternates;
            tracking.hardStop = hasHardStop;
            tracking.beastStop = hasBeastStop;
            tracking.original = word; // Store original for display purposes
            
            // Hard stop handling will be done after all words are processed
            
            return result;
        };
        
        // Process each word (only the ones we need)
        let processedIntro = intro ? processWordWithTracking(intro, wordTracking.intro) : '';
        let processedBeast = beast ? processWordWithTracking(beast, wordTracking.beast) : '';
        let processedNoun = noun ? processWordWithTracking(noun, wordTracking.noun) : '';
        let processedCandy = candy ? processWordWithTracking(candy, wordTracking.candy) : '';
        let processedAdjective = adjective ? processWordWithTracking(adjective, wordTracking.adjective) : '';
        let processedFinale = finale ? processWordWithTracking(finale, wordTracking.finale) : '';
        
        // Initialize tag variables (will be set later if needed)
        let tag = null;
        let processedTag = '';
        let tagTracking = null;
        
        
        
        // Apply random duplications
        let finalBeast = processedBeast;
        let finalNoun = processedNoun;
        let finalCandy = processedCandy;
        
        // Track additional items used in this phrase for timeout system
        let additionalItemsUsed = [];
        
        // Track how many "fucking"s were added for logging
        let fucksGiven = 0;
        
        // Check for beast stop after first beast (only if beast is used)
        if (needsBeast && wordTracking.beast?.beastStop) {
            // Beast stop triggered by first beast - skip beast duplications
            // Continue with normal processing (noun, candy, adjective, finale)
        } else if (needsBeast && !wordTracking.beast?.hardStop && Math.random() < CONFIG.doubleBeastChance) {
            // Get a different beast (avoid duplicates and items on timeout)
            let availableSecondBeasts = getAvailableItems(1).filter(item => item !== beast);
            // If no available beasts (shouldn't happen), fall back to all beasts except the current one
            if (availableSecondBeasts.length === 0) {
                availableSecondBeasts = window.wordLists[1].filter(item => item !== beast);
            }
            const secondBeast = availableSecondBeasts[Math.floor(Math.random() * availableSecondBeasts.length)];
            additionalItemsUsed.push({type: 'beast', item: secondBeast});
            
            const secondBeastTracking = createWordTracking(secondBeast);
            const secondBeastProcessed = processWordWithTracking(secondBeast, secondBeastTracking);
            finalBeast = `${processedBeast} ${secondBeastProcessed}`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('double');
            // Merge add-ons from both beasts
            wordTracking.beast.addons = [...wordTracking.beast.addons, ...secondBeastTracking.addons];
            wordTracking.beast.alternates = [...wordTracking.beast.alternates, ...secondBeastTracking.alternates];
            
            // Check for beast stop after second beast
            if (wordTracking.beast.beastStop || secondBeastTracking.beastStop) {
                // Beast stop triggered by first or second beast - skip third beast
            } else if (!wordTracking.beast?.hardStop && !secondBeastTracking?.hardStop && Math.random() < CONFIG.tripleBeastChance) {
                // Get a different third beast (avoid duplicates with first two and items on timeout)
                let availableThirdBeasts = getAvailableItems(1).filter(item => item !== beast && item !== secondBeast);
                // If no available beasts (shouldn't happen), fall back to all beasts except the current ones
                if (availableThirdBeasts.length === 0) {
                    availableThirdBeasts = window.wordLists[1].filter(item => item !== beast && item !== secondBeast);
                }
                const thirdBeast = availableThirdBeasts[Math.floor(Math.random() * availableThirdBeasts.length)];
                additionalItemsUsed.push({type: 'beast', item: thirdBeast});
                
                const thirdBeastTracking = createWordTracking(thirdBeast);
                const thirdBeastProcessed = processWordWithTracking(thirdBeast, thirdBeastTracking);
                finalBeast = `${finalBeast} ${thirdBeastProcessed}`;
                wordTracking.beast.final = finalBeast;
                wordTracking.beast.modifications.push('triple');
                // Merge add-ons from third beast
                wordTracking.beast.addons = [...wordTracking.beast.addons, ...thirdBeastTracking.addons];
                wordTracking.beast.alternates = [...wordTracking.beast.alternates, ...thirdBeastTracking.alternates];
            }
        }

        // 50% chance to add a second candy (only if candy is used)
        if (needsCandy && !wordTracking.candy?.hardStop && Math.random() < CONFIG.doubleCandyChance) {
            // Get a different candy (avoid duplicates and items on timeout)
            let availableSecondCandies = getAvailableItems(3).filter(item => item !== candy);
            // If no available candies (shouldn't happen), fall back to all candies except the current one
            if (availableSecondCandies.length === 0) {
                availableSecondCandies = window.wordLists[3].filter(item => item !== candy);
            }
            const secondCandy = availableSecondCandies[Math.floor(Math.random() * availableSecondCandies.length)];
            additionalItemsUsed.push({type: 'candy', item: secondCandy});
            
            const secondCandyTracking = createWordTracking(secondCandy);
            const secondCandyProcessed = processWordWithTracking(secondCandy, secondCandyTracking);
            finalCandy = `${processedCandy} ${secondCandyProcessed}`;
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('double');
            // Merge add-ons from both candies
            wordTracking.candy.addons = [...wordTracking.candy.addons, ...secondCandyTracking.addons];
            wordTracking.candy.alternates = [...wordTracking.candy.alternates, ...secondCandyTracking.alternates];
        }
        
        // 10% chance to add "fucking" before beast (only if beast is used)
        if (needsBeast && Math.random() < CONFIG.fuckingChance) {
            finalBeast = `fucking ${finalBeast}`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('fucking');
            fucksGiven++;
        }
        
        // 10% chance to add "fucking" after the entire set of beasts (only if beast is used)
        if (needsBeast && Math.random() < 0.1) {
            finalBeast = `${finalBeast} fucking`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('fucking-after');
            fucksGiven++;
        }
        
        // 10% chance to add "fucking" before noun (only if noun is used)
        if (needsNoun && Math.random() < CONFIG.fuckingChance) {
            finalNoun = `fucking ${finalNoun}`;
            wordTracking.noun.final = finalNoun;
            wordTracking.noun.modifications.push('fucking');
            fucksGiven++;
        }
        
        // 10% chance to add "fucking" before candy (only if candy is used)
        if (needsCandy && Math.random() < CONFIG.fuckingChance) {
            finalCandy = `fucking ${finalCandy}`;
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('fucking');
            fucksGiven++;
        }
        
        // Apply all caps to non-beast items (2% chance each, only if used)
        if (needsIntro && Math.random() < CONFIG.allCapsChance) {
            processedIntro = processedIntro.toUpperCase();
            wordTracking.intro.final = processedIntro;
            wordTracking.intro.modifications.push('all-caps');
        }
        
        if (needsNoun && Math.random() < CONFIG.allCapsChance) {
            finalNoun = finalNoun.toUpperCase();
            wordTracking.noun.final = finalNoun;
            wordTracking.noun.modifications.push('all-caps');
        }
        
        if (needsCandy && Math.random() < CONFIG.allCapsChance) {
            finalCandy = finalCandy.toUpperCase();
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('all-caps');
        }
        
        if (needsAdjective && Math.random() < CONFIG.allCapsChance) {
            processedAdjective = processedAdjective.toUpperCase();
            wordTracking.adjective.final = processedAdjective;
            wordTracking.adjective.modifications.push('all-caps');
        }
        
        if (needsFinale && Math.random() < CONFIG.allCapsChance) {
            processedFinale = processedFinale.toUpperCase();
            wordTracking.finale.final = processedFinale;
            wordTracking.finale.modifications.push('all-caps');
        }
        
        // Check for hard stops before generating phrase
        let hasHardStop = false;
        let hardStopWord = '';
        
        // Combined debug output (only show word types that were actually used)
        // Create words object in the desired order: intro, beast, noun, candy, adjective, finale, tag
        const wordsInOrder = {};
        
        // Add words in the specific order, only if they were used
        if (needsIntro) {
            let introDisplay = processedIntro;
            if (wordTracking.intro?.hardStop) introDisplay += ', *F*';
            if (wordTracking.intro?.beastStop) introDisplay += ', *B*';
            wordsInOrder.intro = introDisplay;
        }
        if (needsBeast) {
            let beastDisplay = finalBeast;
            if (wordTracking.beast?.hardStop) beastDisplay += ', *F*';
            if (wordTracking.beast?.beastStop) beastDisplay += ', *B*';
            wordsInOrder.beast = beastDisplay;
        }
        if (needsNoun) {
            let nounDisplay = finalNoun;
            if (wordTracking.noun?.hardStop) nounDisplay += ', *F*';
            if (wordTracking.noun?.beastStop) nounDisplay += ', *B*';
            wordsInOrder.noun = nounDisplay;
        }
        if (needsCandy) {
            let candyDisplay = finalCandy;
            if (wordTracking.candy?.hardStop) candyDisplay += ', *F*';
            if (wordTracking.candy?.beastStop) candyDisplay += ', *B*';
            wordsInOrder.candy = candyDisplay;
        }
        if (needsAdjective) {
            let adjectiveDisplay = processedAdjective;
            if (wordTracking.adjective?.hardStop) adjectiveDisplay += ', *F*';
            if (wordTracking.adjective?.beastStop) adjectiveDisplay += ', *B*';
            wordsInOrder.adjective = adjectiveDisplay;
        }
        if (needsFinale) {
            let finaleDisplay = processedFinale;
            if (wordTracking.finale?.hardStop) finaleDisplay += ', *F*';
            if (wordTracking.finale?.beastStop) finaleDisplay += ', *B*';
            wordsInOrder.finale = finaleDisplay;
        }
        
        const debugOutput = {
            format: `${formatIndex + 1} (${formatString})`,
            fucksGiven: fucksGiven,
            words: wordsInOrder
        };
        
        // Check each word type for hard stops (only the ones that were processed)
        if (needsIntro && wordTracking.intro?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedIntro;
        } else if (needsBeast && wordTracking.beast?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalBeast;
        } else if (needsNoun && wordTracking.noun?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalNoun;
        } else if (needsCandy && wordTracking.candy?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalCandy;
        } else if (needsAdjective && wordTracking.adjective?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedAdjective;
        } else if (needsFinale && wordTracking.finale?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedFinale;
        }
        
        // Generate phrase using the selected format with modified words
        let phrase;
        if (hasHardStop) {
            // If there's a hard stop, determine which word triggered it and stop there
            // We need to respect the actual format that was selected
            let stopAfterIntro = needsIntro && wordTracking.intro?.hardStop;
            let stopAfterBeast = needsBeast && wordTracking.beast?.hardStop;
            let stopAfterNoun = needsNoun && wordTracking.noun?.hardStop;
            let stopAfterCandy = needsCandy && wordTracking.candy?.hardStop;
            let stopAfterAdjective = needsAdjective && wordTracking.adjective?.hardStop;
            let stopAfterFinale = needsFinale && wordTracking.finale?.hardStop;
            
            // If there's a hard stop, we need to respect the actual format order
            // Determine which word type triggered the hard stop
            let hardStopType = null;
            if (stopAfterIntro) hardStopType = 'intro';
            else if (stopAfterBeast) hardStopType = 'beast';
            else if (stopAfterNoun) hardStopType = 'noun';
            else if (stopAfterCandy) hardStopType = 'candy';
            else if (stopAfterAdjective) hardStopType = 'adjective';
            else if (stopAfterFinale) hardStopType = 'finale';
            
            // Parse the format string to determine the actual order
            const formatOrder = [];
            // Split by spaces and map to word types
            const formatParts = formatString.split(' ');
            formatParts.forEach(part => {
                switch(part) {
                    case 'I': formatOrder.push('intro'); break;
                    case 'B': formatOrder.push('beast'); break;
                    case 'N': formatOrder.push('noun'); break;
                    case 'C': formatOrder.push('candy'); break;
                    case 'A': formatOrder.push('adjective'); break;
                    case 'F': formatOrder.push('finale'); break;
                }
            });
            
            // Find the position of the hard stop word in the format order
            const stopIndex = formatOrder.indexOf(hardStopType);
            
            
            // Determine which words to include (up to and including the hard stop word, then stop)
            let includeIntro = needsIntro && (stopIndex === -1 || formatOrder.indexOf('intro') <= stopIndex);
            let includeBeast = needsBeast && (stopIndex === -1 || formatOrder.indexOf('beast') <= stopIndex);
            let includeNoun = needsNoun && (stopIndex === -1 || formatOrder.indexOf('noun') <= stopIndex);
            let includeCandy = needsCandy && (stopIndex === -1 || formatOrder.indexOf('candy') <= stopIndex);
            let includeAdjective = needsAdjective && (stopIndex === -1 || formatOrder.indexOf('adjective') <= stopIndex);
            let includeFinale = needsFinale && (stopIndex === -1 || formatOrder.indexOf('finale') <= stopIndex);
            
            
            // Build the phrase with only the words that should be included
            phrase = randomFormat(
                includeIntro ? processedIntro : '',
                includeBeast ? finalBeast : '',
                includeNoun ? finalNoun : '',
                includeCandy ? finalCandy : '',
                includeAdjective ? processedAdjective : '',
                includeFinale ? processedFinale : ''
            );
        } else {
            // Normal phrase generation
            phrase = randomFormat(processedIntro, finalBeast, finalNoun, finalCandy, processedAdjective, processedFinale);
        }
        
        // Clean up any double "fucking" in a row and remove markers (optimized)
        phrase = phrase.replace(/\bfucking\s+fucking\b|\*[FB]\*/g, (match) => {
            return match.includes('fucking') ? 'fucking' : '';
        });
        
        // Clean up phrase formatting
        phrase = cleanPhrase(phrase);
        
        // Apply child's mode filtering if enabled
        phrase = filterNSFW(phrase);
        
        // Apply letter swapping chaos (0.5% chance)
        const letterSwapResult = applyLetterSwapping(phrase);
        phrase = letterSwapResult.phrase;
        const swappedWords = letterSwapResult.swappedWords;
        
        // Check for tag addition (10% chance after finale or hard stop)
        // Tags appear after finales (normal completion) or hard stops
        const shouldAddTag = (needsFinale || hasHardStop) && Math.random() < CONFIG.tagChance;
        
        if (shouldAddTag) {
            // Get a random tag from available tags
            const availableTags = getAvailableItems(6); // Tags are at index 6
            if (availableTags.length > 0) {
                tag = availableTags[Math.floor(Math.random() * availableTags.length)];
                tagTracking = createWordTracking(tag);
                
                // Process the tag word
                processedTag = processWordWithTracking(tag, tagTracking);
                
                // Check if the previous word type was made all-caps and inherit it
                let lastWordTypeWasAllCaps = false;
                
                if (hasHardStop) {
                    // Determine which word type triggered the hard stop (that's our last word)
                    if (needsIntro && wordTracking.intro?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.intro?.modifications?.includes('all-caps') || false;
                    } else if (needsBeast && wordTracking.beast?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.beast?.modifications?.includes('all-caps') || false;
                    } else if (needsNoun && wordTracking.noun?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.noun?.modifications?.includes('all-caps') || false;
                    } else if (needsCandy && wordTracking.candy?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.candy?.modifications?.includes('all-caps') || false;
                    } else if (needsAdjective && wordTracking.adjective?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.adjective?.modifications?.includes('all-caps') || false;
                    } else if (needsFinale && wordTracking.finale?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.finale?.modifications?.includes('all-caps') || false;
                    }
                } else {
                    // Normal completion - check if finale was made all-caps
                    if (needsFinale) {
                        lastWordTypeWasAllCaps = wordTracking.finale?.modifications?.includes('all-caps') || false;
                    }
                }
                
                // Apply all-caps to tag if previous word was all-caps
                if (lastWordTypeWasAllCaps) {
                    processedTag = processedTag.toUpperCase();
                    tagTracking.final = processedTag;
                    tagTracking.modifications.push('all-caps-inherited');
                }
                
                // Add to timeout system
                addItemToTimeout('tag', tag); // Add the tag item to the tag list
                additionalItemsUsed.push({type: 'tag', item: tag});
                
                // Add the tag to the end of the phrase
                phrase = addTagToPhrase(phrase, processedTag);
                
                // Add tag to debug output
                let tagDisplay = processedTag;
                if (tagTracking?.hardStop) tagDisplay += ', *F*';
                if (tagTracking?.beastStop) tagDisplay += ', *B*';
                debugOutput.words.tag = tagDisplay;
            }
        }
        
        // Log debug output after all processing is complete
        if (!CONFIG.noConsole) {
          console.log('üé™', debugOutput);
        }
        
        // Add used items to timeout list to prevent repetition (only the ones that were actually used)
        if (needsIntro && intro) addItemToTimeout('intro', intro);
        if (needsBeast && beast) addItemToTimeout('beast', beast);
        if (needsNoun && noun) addItemToTimeout('noun', noun);
        if (needsCandy && candy) addItemToTimeout('candy', candy);
        if (needsAdjective && adjective) addItemToTimeout('adjective', adjective);
        if (needsFinale && finale) addItemToTimeout('finale', finale);
        if (tag) addItemToTimeout('tag', tag);
        
        // Add additional beasts and candies that were used
        additionalItemsUsed.forEach(({type, item}) => {
            addItemToTimeout(type, item);
        });
        
        // Decrement all timeout counters for next phrase
        decrementTimeouts();
        
        // Animate typing the phrase
        typeOutPhrase(phrase, swappedWords);
        
        // Generate detailed format display
        // const formatDisplay = document.getElementById('format-display');
        // if (formatDisplay) {
        //     const detailedFormat = generateDetailedFormatString(phrase, randomFormat, wordTracking, formatIndex + 1);
        //     formatDisplay.textContent = `Format ${formatIndex + 1}: ${detailedFormat}`;
        // }
        
        // Copy button will be shown after typing animation completes
    };
    
    // Helper function to generate detailed format string with inline annotations
    const generateDetailedFormatString = (phrase, format, wordTracking, formatNumber) => {
        // Create a test phrase to determine the format structure
        const testPhrase = format('I', 'B', 'N', 'C', 'A', 'F');
        const testParts = testPhrase.split(' ');
        
        // Map test parts to their types
        const typeMap = {};
        testParts.forEach((part, index) => {
            if (part === 'I') typeMap[index] = 'I';
            else if (part === 'B') typeMap[index] = 'B';
            else if (part === 'N') typeMap[index] = 'N';
            else if (part === 'C') typeMap[index] = 'C';
            else if (part === 'A') typeMap[index] = 'A';
            else if (part === 'F') typeMap[index] = 'F';
        });
        
        let result = [];
        let literalWords = [];
        
        // Process each part of the test phrase
        testParts.forEach((testPart, testIndex) => {
            if (testPart === 'I' || testPart === 'B' || testPart === 'N' || testPart === 'C' || testPart === 'A' || testPart === 'F') {
                // This is a variable position - first flush any accumulated literal words
                if (literalWords.length > 0) {
                    result.push(`"${literalWords.join(' ')}"`);
                    literalWords = [];
                }
                
                const type = typeMap[testIndex];
                const wordData = wordTracking[type === 'I' ? 'intro' : type === 'B' ? 'beast' : type === 'N' ? 'noun' : type === 'C' ? 'candy' : type === 'A' ? 'adjective' : 'finale'];
                
                // Use the final processed word, not the original
                let displayWord = wordData.final;
                
                // Add quotes around "fucking" if it was added (before or after)
                if (wordData.modifications.includes('fucking')) {
                    displayWord = displayWord.replace(/^fucking /, '"fucking" ');
                }
                if (wordData.modifications.includes('fucking-after')) {
                    displayWord = displayWord.replace(/ fucking$/, ' "fucking"');
                }
                
                // Remove hard stop markers (*F*) and beast stop markers (*B*) from display
                displayWord = displayWord.replace(/\*F\*/g, '');
                displayWord = displayWord.replace(/\*B\*/g, '');
                
                // Add back brackets for add-ons that were actually included
                if (wordData.addons.length > 0) {
                    wordData.addons.forEach(addon => {
                        const cleanAddon = addon.replace(/,\s*\d*\.?\d+$/, '');
                        // Find where this addon content appears in the final word and wrap it in brackets
                        if (wordData.final.includes(cleanAddon)) {
                            displayWord = displayWord.replace(cleanAddon, `[${cleanAddon}]`);
                        }
                    });
                }
                
                // Add back alternates for alternates that were actually selected
                if (wordData.alternates.length > 0) {
                    wordData.alternates.forEach(alt => {
                        const cleanAlt = alt.replace('alt: ', '');
                        // Find where this alternate content appears in the final word and wrap it in parentheses
                        if (wordData.final.includes(cleanAlt)) {
                            displayWord = displayWord.replace(cleanAlt, `(${cleanAlt})`);
                        }
                    });
                }
                
                // Add the processed word as a single unit
                result.push(displayWord);
                
                // Add type annotation after brackets
                result[result.length - 1] += ` (${type})`;
                
                // Add hard stop marker if this word triggered a hard stop
                if (wordData.hardStop) {
                    result[result.length - 1] += ' *F*';
                }
                
                // Add beast stop marker if this word triggered a beast stop
                if (wordData.beastStop) {
                    result[result.length - 1] += ' *B*';
                }
                
                // Add modification annotations
                if (wordData.modifications.includes('triple')) {
                    result[result.length - 1] += ' (3)';
                } else if (wordData.modifications.includes('double')) {
                    result[result.length - 1] += ' (2)';
                }
            } else {
                // This is literal text - accumulate it
                literalWords.push(testPart);
            }
        });
        
        // Flush any remaining literal words
        if (literalWords.length > 0) {
            result.push(`"${literalWords.join(' ')}"`);
        }
        
        return result.join(' ');
    };
    
    /**
     * Updates button state classes and text
     */
    const updateButtonState = (state) => {
      generateBtn.classList.remove('filling', 'ready');
      generateBtn.classList.add(state);
      
      // Update button text based on state
      const btnText = generateBtn.querySelector('.btn-text');
      if (state === 'filling') {
        btnText.textContent = '';
      } else if (state === 'ready') {
        btnText.textContent = 'GO';
      }
    };

    /**
      * Updates child's mode toggle appearance
      */
     const updatechildsModeToggle = () => {
       if (CONFIG.childsMode) {
         childsModeToggle.classList.add('bg-pink-500');
         childsModeToggle.classList.remove('bg-gray-200');
         childsModeSlider.classList.add('translate-x-5');
         childsModeSlider.classList.remove('translate-x-0');
      } else {
         childsModeToggle.classList.remove('bg-pink-500');
         childsModeToggle.classList.add('bg-gray-200');
         childsModeSlider.classList.remove('translate-x-5');
         childsModeSlider.classList.add('translate-x-0');
       }
     };


     /**
      * Toggles child's mode on/off
      */
     const togglechildsMode = () => {
       CONFIG.childsMode = !CONFIG.childsMode;
       updatechildsModeToggle();
       
       // Handle music switching
       if (CONFIG.backgroundMusic) {
         if (CONFIG.childsMode) {
           // Switch to child's mode music
           if (!backgroundMusic.paused) {
             mainMusicPosition = backgroundMusic.currentTime;
             backgroundMusic.pause();
           }
           childsModeMusic.volume = CONFIG.musicVolume;
           childsModeMusic.currentTime = childsMusicPosition;
           childsModeMusic.loop = true;
           childsModeMusic.play().catch(err => {
             if (!CONFIG.noConsole) {
               console.log('Child\'s mode music failed to play');
             }
           });
         } else {
           // Switch back to main music
           if (!childsModeMusic.paused) {
             childsMusicPosition = childsModeMusic.currentTime;
             childsModeMusic.pause();
           }
           backgroundMusic.currentTime = mainMusicPosition;
           if (backgroundMusic.paused) {
             backgroundMusic.play().catch(err => {
               if (!CONFIG.noConsole) {
                 console.log('Main music failed to resume');
               }
             });
           }
         }
       }
       
       // Add/remove childs-mode class to body for CSS styling
       if (CONFIG.childsMode) {
         document.body.classList.add('childs-mode');
       } else {
         document.body.classList.remove('childs-mode');
       }
       
       // Update GO button text if it's currently ready
       if (generateBtn.classList.contains('ready')) {
         const btnText = generateBtn.querySelector('.btn-text');
           btnText.textContent = 'GO';
       }
     };

     /**
      * Toggles dark mode on/off
      */
     const toggleDarkMode = () => {
       CONFIG.darkMode = !CONFIG.darkMode;
       
       if (CONFIG.darkMode) {
         // Enable dark mode
         document.body.classList.add('dark');
         darkModeIcon.textContent = '‚òÄÔ∏è';
         darkModeIcon.alt = 'Light Mode';
         
         // Switch to dark volume icons
         if (backgroundMusic.muted) {
           muteIcon.src = 'images/mute-dark.png';
         } else {
           muteIcon.src = 'images/volume-dark.png';
         }
       } else {
         // Disable dark mode
         document.body.classList.remove('dark');
         darkModeIcon.textContent = 'üåô';
         darkModeIcon.alt = 'Dark Mode';
         
         // Switch to light volume icons
         if (backgroundMusic.muted) {
           muteIcon.src = 'images/mute.png';
         } else {
           muteIcon.src = 'images/volume.png';
         }
       }
     };

     /**
      * Toggles background music on/off
      */
     const toggleMusic = () => {
       if (backgroundMusic.muted) {
         // Unmute
         backgroundMusic.muted = false;
         childsModeMusic.muted = false;
         muteIcon.src = CONFIG.darkMode ? 'images/volume-dark.png' : 'images/volume.png';
         muteIcon.alt = 'Volume';
         muteBtn.classList.remove('muted');
         updatePlayingState();
       } else {
         // Mute
         backgroundMusic.muted = true;
         childsModeMusic.muted = true;
         muteIcon.src = CONFIG.darkMode ? 'images/mute-dark.png' : 'images/mute.png';
         muteIcon.alt = 'Muted';
         muteBtn.classList.add('muted');
         muteBtn.classList.remove('playing');
       }
    };
    
    /**
     * Shows toast notification
     */
    const showToast = () => {
      toast.classList.remove('opacity-0');
      setTimeout(() => {
        toast.classList.add('opacity-0');
      }, 2000);
    };
    
    /**
     * Animate typing out a phrase with realistic human-like patterns including typo correction
     */
    const typeOutPhrase = (phrase, swappedWords = new Set()) => {
        // check to ensure phrase is defined
        if (!phrase || typeof phrase !== 'string') {
            console.error('typeOutPhrase called with invalid phrase:', phrase);
            return;
        }
        
        // Clear any existing typing animations to prevent conflicts
        clearTypingTimeouts();
        
        // Clear the phrase output first
        phraseOutput.textContent = '';
        
        // Mark typing as active
        isTyping = true;
        
        let currentIndex = 0;
        let typingSpeed = 1.0; // Dynamic speed multiplier
        let lastCharTime = 0;
        let soundCounter = 0; // Counter for playing sounds on every other letter
        let pendingCorrections = []; // Track typos that need correction
        let displayedText = ''; // Track what's actually displayed
        let hasActiveTypo = false; // Prevent multiple typos
        
        // Optimized timing using requestAnimationFrame for smoother performance
        let rafId = null;
        const scheduleNextChar = (delay) => {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(() => {
                const timeoutId = setTimeout(typeNextChar, delay);
                typingTimeouts.push(timeoutId);
            });
        };

        const typeNextChar = () => {
            if (currentIndex < phrase.length) {
                const char = phrase[currentIndex];
                const prevChar = currentIndex > 0 ? phrase[currentIndex - 1] : '';
                
                // Check for various random effects
                let actualChar = char;
                
                // Skip spaces between words (if enabled)
                if (char === ' ' && CONFIG.skipSpaceChance > 0 && Math.random() < CONFIG.skipSpaceChance) {
                    // Skip this space - don't add to displayedText
                    currentIndex++;
                    scheduleNextChar(Math.round(getBaseDelay(char, prevChar)));
                    return;
                }
                
                // Check if this is the first or last letter of a word (immune to skipping/doubling)
                let isFirstLetterOfWord = false;
                let isLastLetterOfWord = false;
                
                if (char !== ' ') {
                    // Check if previous char is space or start of phrase (first letter of word)
                    isFirstLetterOfWord = (currentIndex === 0 || phrase[currentIndex - 1] === ' ');
                    
                    // Check if next char is space or end of phrase (last letter of word)
                    isLastLetterOfWord = (currentIndex === phrase.length - 1 || phrase[currentIndex + 1] === ' ');
                }
                
                
                // Check if we should introduce a typo (1% chance per letter, but only if no active typo)
                // Also check if current word was letter-swapped (immune to typos)
                let currentWord = '';
                if (char !== ' ') {
                    // Find the current word being typed
                    let wordStart = currentIndex;
                    while (wordStart > 0 && phrase[wordStart - 1] !== ' ') {
                        wordStart--;
                    }
                    let wordEnd = currentIndex;
                    while (wordEnd < phrase.length && phrase[wordEnd] !== ' ') {
                        wordEnd++;
                    }
                    currentWord = phrase.substring(wordStart, wordEnd);
                }
                
                // Check if we're at the last word (immune from typos)
                const remainingPhrase = phrase.substring(currentIndex + 1).trim();
                const wordsLeft = remainingPhrase.split(' ').filter(word => word.length > 0);
                const isLastWord = wordsLeft.length <= 1;
                
                let shouldMakeTypo = !hasActiveTypo && 
                                   Math.random() < CONFIG.typoChance && 
                                   char.match(/[a-zA-Z]/) && 
                                   !swappedWords.has(currentWord) &&
                                   !isLastWord; // Last word is immune from typos
                
                if (shouldMakeTypo) {
                    // Make a typo based on QWERTY keyboard layout
                    actualChar = getTypoChar(char);
                    hasActiveTypo = true; // Prevent more typos
                }
                
                // Add the character (could be original or typo)
                displayedText += actualChar;
                
                // Play typewriter sound for letters and spaces
                if (actualChar.match(/[a-zA-Z ]/)) {
                    if (actualChar === ' ') {
                        // Space bar: Use random sound (30% louder)
                        if (window.typewriterSounds && window.typewriterSounds.length > 0) {
                            const sound = window.typewriterSounds[Math.floor(Math.random() * window.typewriterSounds.length)];
                            if (sound.currentTime > 0.1) {
                                sound.currentTime = 0;
                            }
                            
                            // 30% louder for spacebar
                            const originalVolume = sound.volume;
                            sound.volume = Math.min(originalVolume * 1.3, 1.0);
                            sound.play().catch(() => {});
                            sound.volume = originalVolume; // Reset volume
                        }
                    } else {
                        // Letters use very-soft-hit sounds (variable frequency)
                        soundCounter++;
                        if (soundCounter % 3 === 0) {
                            // Check if this is a capital letter
                            if (actualChar === actualChar.toUpperCase() && actualChar.match(/[A-Z]/)) {
                                // Capital letters are 50% louder
                                if (window.typewriterSounds && window.typewriterSounds.length > 0) {
                                    const sound = window.typewriterSounds[Math.floor(Math.random() * window.typewriterSounds.length)];
                                    if (sound.currentTime > 0.1) {
                                        sound.currentTime = 0;
                                    }
                                    
                                    const originalVolume = sound.volume;
                                    sound.volume = Math.min(originalVolume * 1.5, 1.0);
                                    sound.play().catch(() => {});
                                    sound.volume = originalVolume; // Reset volume
                                }
                            } else {
                                playTypewriterSound(actualChar);
                            }
                            
                            // 50% chance to skip ahead, creating mix of every 2-3 letters
                            if (Math.random() < 0.5) {
                                soundCounter++;
                            }
                        }
                    }
                }
                
                phraseOutput.textContent = displayedText;
                currentIndex++;
                
                // Check if we're at the end of a word (space or end of phrase)
                const isEndOfWord = char === ' ' || currentIndex >= phrase.length;
                
                // Check word timing for carriage sound
                if (char === ' ' && currentIndex < phrase.length) {
                    // We just typed a space, check what's left
                    const remainingPhrase = phrase.substring(currentIndex).trim();
                    const wordsLeft = remainingPhrase.split(' ').filter(word => word.length > 0);
                    
                    if (wordsLeft.length === 1) {
                        // This is the last word - play carriage sound
                        playCarriageSound();
                    }
                }
                
                if (isEndOfWord && hasActiveTypo) {
                    // We've finished typing a word that had a typo - check if we should correct it
                    // Calculate correction chance based on typo position
                    let correctionChance = CONFIG.typoCorrectionChance; // Default 80%
                    
                    // Check if this is the last word in the phrase
                    const isLastWord = currentIndex >= phrase.length;
                    
                    let wordEndIndex, wordStartIndex, displayedWordEnd, displayedWordStartIndex;
                    
                    if (isLastWord) {
                        // Special handling for the last word - use phrase length as boundary
                        wordEndIndex = phrase.length;
                        wordStartIndex = wordEndIndex - 1;
                        while (wordStartIndex > 0 && phrase[wordStartIndex - 1] !== ' ') {
                            wordStartIndex--;
                        }
                        
                        // For displayed text: use full length as boundary
                        displayedWordEnd = displayedText.length;
                        displayedWordStartIndex = displayedWordEnd - 1;
                        while (displayedWordStartIndex > 0 && displayedText[displayedWordStartIndex - 1] !== ' ') {
                            displayedWordStartIndex--;
                        }
                    } else {
                        // Normal handling for non-last words
                        wordEndIndex = char === ' ' ? currentIndex - 1 : currentIndex;
                        wordStartIndex = wordEndIndex - 1;
                        while (wordStartIndex > 0 && phrase[wordStartIndex - 1] !== ' ') {
                            wordStartIndex--;
                        }
                        
                        // For displayed text: find the last complete word
                        displayedWordEnd = displayedText.length;
                        if (displayedText[displayedText.length - 1] === ' ') {
                            displayedWordEnd = displayedText.length - 1;
                        }
                        displayedWordStartIndex = displayedWordEnd - 1;
                        while (displayedWordStartIndex > 0 && displayedText[displayedWordStartIndex - 1] !== ' ') {
                            displayedWordStartIndex--;
                        }
                    }
                    
                    // Get the displayed word (what we actually typed)
                    const displayedWord = displayedText.substring(displayedWordStartIndex, displayedWordEnd);
                    
                    // Get the correct word from the original phrase
                    const correctWord = phrase.substring(wordStartIndex, wordEndIndex);
                    
                    // Find the first character that differs
                    let typoPosition = 0;
                    while (typoPosition < Math.min(displayedWord.length, correctWord.length) && 
                           displayedWord[typoPosition] === correctWord[typoPosition]) {
                        typoPosition++;
                    }
                    
                    // Adjust correction chance based on typo position
                    if (typoPosition === 0) {
                        correctionChance = 1.0; // 100% chance for first letter
                    } else if (typoPosition === displayedWord.length - 1) {
                        correctionChance = 1.0; // 100% chance for last letter
                    } else {
                        correctionChance = CONFIG.typoCorrectionChance; // Use CONFIG value for middle letters only
                    }
                    
                    if (Math.random() < correctionChance) {
                        // Compare and correct if different
                        if (correctWord !== displayedWord) {
                            correctWordTypo(wordStartIndex, correctWord, displayedWordStartIndex);
                            return; // Don't continue until correction is done
                        }
                    }
                    
                    // Reset typo flag for next word
                    hasActiveTypo = false;
                }
                
                // Calculate realistic delay based on multiple factors
                let baseDelay;
                
                if (CONFIG.testMode) {
                    // Test mode: super fast typing (1-3ms per character)
                    baseDelay = 1 + Math.random() * 2;
                } else {
                    // Normal mode: realistic human typing
                    baseDelay = getBaseDelay(actualChar, prevChar);
                
                // Apply dynamic speed variation (human rhythm changes)
                typingSpeed += (Math.random() - 0.5) * 0.1; // Gradual speed changes
                typingSpeed = Math.max(0.3, Math.min(1.8, typingSpeed)); // Clamp between 0.3x and 1.8x
                baseDelay *= typingSpeed;
                
                // Add natural rhythm variations
                const rhythmVariation = 0.5 + Math.random() * 1.0; // 0.5x to 1.5x variation
                baseDelay *= rhythmVariation;
                }
                
                if (!CONFIG.testMode) {
                    // Normal mode: apply all the realistic human typing effects
                
                // Simulate typing bursts (fast sequences followed by pauses)
                const timeSinceLastChar = Date.now() - lastCharTime;
                if (timeSinceLastChar > 200) { // After a pause, start with slower typing
                    baseDelay *= 1.5;
                }
                
                // Natural pauses after punctuation
                if (prevChar.match(/[.!?]/)) {
                    baseDelay += 33.33 + Math.random() * 66.67; // Extra pause after sentences (3/4ths slower)
                } else if (prevChar.match(/[,;:]/)) {
                    baseDelay += 13.33 + Math.random() * 33.33; // Shorter pause after commas (3/4ths slower)
                }
                
                // Occasional longer thinking pauses (more frequent than before)
                if (Math.random() < CONFIG.thinkingPauseChance) { // 8% chance
                    baseDelay += 66.67 + Math.random() * 133.33; // Longer thinking pause (3/4ths slower)
                }
                
                // Simulate finger fatigue (gradually slower over time)
                const fatigueFactor = 1 + (currentIndex / phrase.length) * 0.08; // Up to 8% slower
                baseDelay *= fatigueFactor;
                
                // Word boundaries get slight pauses
                if (char === ' ') {
                    baseDelay += 8 + Math.random() * 13.33; // 3/4ths slower
                    }
                }
                
                lastCharTime = Date.now();
                
                // Schedule next character using optimized timing
                scheduleNextChar(Math.round(baseDelay));
            } else {
                // Typing complete - but only if no active typo correction
                if (!hasActiveTypo) {
                    // Play bell sound when phrase is complete
                    playBellSound();
                    
                    // Show copy button and mark typing as inactive
                copyBtn.classList.remove('opacity-0');
                    isTyping = false;
                    typingTimeouts = []; // Clear the timeout array since we're done
                }
                // If there's an active typo, let the correction complete first
            }
        };
        
        // Function to correct a word typo by comparing and fixing
        const correctWordTypo = (wordStartIndex, correctWord, displayedWordStartIndex) => {
            // Get the current displayed word
            const displayedWord = displayedText.substring(displayedWordStartIndex).trim();
            
            // Find the first character that differs
            let typoPosition = 0;
            while (typoPosition < Math.min(displayedWord.length, correctWord.length) && 
                   displayedWord[typoPosition] === correctWord[typoPosition]) {
                typoPosition++;
            }
            
            // If no difference found, something went wrong - just continue
            if (typoPosition >= displayedWord.length && displayedWord.length === correctWord.length) {
                hasActiveTypo = false;
                typeNextChar();
                return;
            }
            
            // Calculate how many characters to backspace (from end of word to typo position, including the typo)
            const charsToBackspace = displayedWord.length - typoPosition + 1;
            let backspaceCount = 0;
            
            const backspace = () => {
                if (backspaceCount < charsToBackspace) {
                    displayedText = displayedText.substring(0, displayedText.length - 1);
                    phraseOutput.textContent = displayedText;
                    backspaceCount++;
                    
                    // Play very-soft-hit sound for backspace (every other character)
                    if (backspaceCount % 2 === 0) {
                        playBackspaceSound(backspaceCount, charsToBackspace);
                    }
                    
                    // Calculate backspace delay
                    let delay;
                    if (CONFIG.testMode) {
                        delay = 1; // Super fast backspacing in test mode
                    } else {
                    // Slow down as we approach the typo (start fast, end slow)
                    const progress = backspaceCount / charsToBackspace; // 0 to 1
                    const speedMultiplier = 1 + (progress * 3); // 1x to 4x slower
                    const baseDelay = 15 + Math.random() * 25; // Original fast delay
                        delay = baseDelay * speedMultiplier * (2 - CONFIG.typingSpeedMultiplier); // Apply slowdown and typing speed multiplier
                    }
                    
                    // Use optimized timing for backspace
                    if (rafId) cancelAnimationFrame(rafId);
                    rafId = requestAnimationFrame(() => {
                        const timeoutId = setTimeout(backspace, delay);
                        typingTimeouts.push(timeoutId);
                    });
                } else {
                    // Now continue typing from the typo position
                    let continuePosition = wordStartIndex + typoPosition;
                    
                    // Special fix for last word: start one position earlier
                    // const isLastWord = currentIndex >= phrase.length;
                    // if (isLastWord && typoPosition > 0) {
                    //     continuePosition = wordStartIndex + typoPosition - 1;
                    // }
                    
                    continueTypingFromWordTypo(continuePosition);
                }
            };
            
            backspace();
        };
        
        // Function to continue typing from a word typo position
        const continueTypingFromWordTypo = (phrasePosition) => {
            // Update currentIndex to match where we are in the original phrase
            currentIndex = phrasePosition;
            
            // Reset typo flag and continue normal typing
            hasActiveTypo = false;
            typeNextChar();
        };
        
        // Function to continue typing from the typo position
        const continueTypingFromTypo = (typoIndex) => {
            // Update currentIndex to match where we are in the original phrase
            currentIndex = typoIndex;
            
            // Reset typo flag and continue normal typing
            hasActiveTypo = false;
            typeNextChar();
        };
        
        // Function to retype a word correctly (kept for compatibility)
        const retypeWord = (wordStartIndex, wordEndIndex) => {
            let retypeIndex = wordStartIndex;
            const retype = () => {
                if (retypeIndex < wordEndIndex) {
                    const char = phrase[retypeIndex];
                    displayedText += char;
                    phraseOutput.textContent = displayedText;
                    retypeIndex++;
                    const retypeDelay = CONFIG.testMode ? 1 : ((15 + Math.random() * 25) * (2 - CONFIG.typingSpeedMultiplier)); // Apply typing speed multiplier
                    // Use optimized timing for retype
                    if (rafId) cancelAnimationFrame(rafId);
                    rafId = requestAnimationFrame(() => {
                        const timeoutId = setTimeout(retype, retypeDelay);
                        typingTimeouts.push(timeoutId);
                    });
                } else {
                    // Word retyped correctly
                    
                    // Remove this correction from pending list
                    const correctionIndex = pendingCorrections.findIndex(c => c.typoIndex === wordStartIndex);
                    if (correctionIndex !== -1) {
                        pendingCorrections.splice(correctionIndex, 1);
                    }
                    
                    // Reset the active typo flag
                    hasActiveTypo = false;
                    
                    // Continue typing from where we left off in the original phrase
                    const continueDelay = CONFIG.testMode ? 1 : ((25 + Math.random() * 50) * (2 - CONFIG.typingSpeedMultiplier)); // Apply typing speed multiplier
                    scheduleNextChar(continueDelay);
                }
            };
            
            retype();
        };

        
        // Use the optimized getTypoChar function defined globally
        
        // Helper function to get base delay for character types
        const getBaseDelay = (char, prevChar) => {
            let baseDelay;
            if (char === ' ') {
                baseDelay = CONFIG.typingSpeed.space.min + Math.random() * (CONFIG.typingSpeed.space.max - CONFIG.typingSpeed.space.min);
            } else if (char.match(/[a-zA-Z]/)) {
                // Vowels are typically typed faster than consonants
                if (char.match(/[aeiouAEIOU]/)) {
                    baseDelay = CONFIG.typingSpeed.vowel.min + Math.random() * (CONFIG.typingSpeed.vowel.max - CONFIG.typingSpeed.vowel.min);
                } else {
                    baseDelay = CONFIG.typingSpeed.consonant.min + Math.random() * (CONFIG.typingSpeed.consonant.max - CONFIG.typingSpeed.consonant.min);
                }
            } else if (char.match(/[0-9]/)) {
                baseDelay = CONFIG.typingSpeed.number.min + Math.random() * (CONFIG.typingSpeed.number.max - CONFIG.typingSpeed.number.min);
            } else {
                baseDelay = CONFIG.typingSpeed.punctuation.min + Math.random() * (CONFIG.typingSpeed.punctuation.max - CONFIG.typingSpeed.punctuation.min);
            }
            
            // Apply typing speed multiplier
            // Lower multiplier = faster typing (shorter delays)
            // Higher multiplier = slower typing (longer delays)
            return baseDelay * (2 - CONFIG.typingSpeedMultiplier);
        };
        
        // Start typing
        lastCharTime = Date.now();
        typeNextChar();
    };


    /**
     * Copies phrase to clipboard
     */
    const copyToClipboard = async () => {
      try {
        await navigator.clipboard.writeText(phraseOutput.textContent);
        showToast();
      } catch (err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = phraseOutput.textContent;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showToast();
      }
    };
    
    /**
     * Starts the auto-fill animation
     */
    const startAutoFill = () => {
      if (isComplete) return; // Don't restart if already complete
      
      currentFill = 0;
      // Temporarily disable transition for instant reset
      generateBtn.style.setProperty('--fill-width', '0%');
      updateButtonState('filling');
      
      // Test mode: instantly complete the bar
      if (CONFIG.testMode) {
        currentFill = totalSteps;
        generateBtn.style.setProperty('--fill-width', '100%');
        updateButtonState('ready');
        isComplete = true;
        return;
      }
      
      // Normal mode: gradual fill
      fillInterval = setInterval(() => {
        currentFill++;
        const fillPercentage = (currentFill / totalSteps) * 100;
        generateBtn.style.setProperty('--fill-width', `${fillPercentage}%`);
        
        // Play page-turn sound when progress hits 95% (only once)
        if (fillPercentage >= 95 && fillPercentage < 96 && !pageTurnPlayed) {
          playPageTurn();
          pageTurnPlayed = true;
        }
        
        // When the button is full, mark as ready (no phrase generation yet)
        if (currentFill >= totalSteps) {
          clearInterval(fillInterval);
          updateButtonState('ready');
          isComplete = true;
        }
      }, CONFIG.updateInterval);
    };

    // --- EVENT LISTENERS ---
    // Copy button functionality - only works when visible
    copyBtn.addEventListener('click', (event) => {
      // Only copy if button is visible (not opacity-0)
      const isVisible = !copyBtn.classList.contains('opacity-0');
      if (isVisible) {
        copyToClipboard();
      }
      // If not visible, just let the click bubble up to advance progress bar
    });
    
     // child's mode toggle functionality
     childsModeToggle.addEventListener('click', togglechildsMode);
     
     // Keyboard shortcuts
     document.addEventListener('keydown', (event) => {
       // Only trigger shortcuts if not typing in an input field
       if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
         switch(event.key.toLowerCase()) {
           case 'm':
             toggleMusic();
             break;
           case 'd':
             toggleDarkMode();
             break;
           case 'c':
             togglechildsMode();
             break;
         }
       }
     });
     
     // Mute button functionality
    const muteBtn = document.getElementById('mute-btn');
    const muteIcon = document.getElementById('mute-icon');
    
    muteBtn.addEventListener('click', toggleMusic);
    
    // Dark mode button functionality
    const darkModeBtn = document.getElementById('dark-mode-btn');
    const darkModeIcon = document.getElementById('dark-mode-icon');
    const body = document.body;
    
    darkModeBtn.addEventListener('click', toggleDarkMode);
    
    // Function to update playing state animation
    function updatePlayingState() {
      const mainMusicPlaying = !backgroundMusic.paused && !backgroundMusic.muted;
      const childsMusicPlaying = !childsModeMusic.paused && !childsModeMusic.muted;
      
      if (mainMusicPlaying || childsMusicPlaying) {
        muteBtn.classList.add('playing');
      } else {
        muteBtn.classList.remove('playing');
      }
    }
    
    // Function to advance progress bar
    const advanceProgress = () => {
      if (!isComplete) {
        // Advance the fill by configured amount
        const advanceAmount = totalSteps * CONFIG.advanceAmount;
        currentFill = Math.min(currentFill + advanceAmount, totalSteps);
        
        const fillPercentage = (currentFill / totalSteps) * 100;
        generateBtn.style.setProperty('--fill-width', `${fillPercentage}%`);
        
        // Play page-turn sound when progress hits 95% (only once)
        if (fillPercentage >= 98 && !pageTurnPlayed) {
          playPageTurn();
          pageTurnPlayed = true;
        }
        
        // Check if we've reached completion
        if (currentFill >= totalSteps) {
          clearInterval(fillInterval);
          updateButtonState('ready');
          isComplete = true;
        }
      }
    };

    // Add click functionality to advance loading by 1% or restart when ready
    generateBtn.addEventListener('click', (event) => {
      if (!isComplete) {
        // Advance progress when button is clicked during filling
        advanceProgress();
      } else {
        // Button is ready - generate new phrase and restart
        playMedHit(); // Play med-hit sound when user clicks GO
        generateNewPhrase();
        isComplete = false;
        pageTurnPlayed = false; // Reset page-turn flag for next cycle
        
        // Remove all classes and reset fill bar instantly (no transitions)
        generateBtn.classList.remove('ready', 'filling');
        
        // Disable transitions temporarily for instant reset
        generateBtn.style.transition = 'none';
        generateBtn.style.setProperty('--fill-width', '0%');
        
        // Force a reflow to ensure immediate reset
        generateBtn.offsetHeight;
        
        // Re-enable transitions after reset
        generateBtn.style.transition = '';
        
        startAutoFill();
      }
    });
    
    // Add keyboard functionality (desktop only)
    document.addEventListener('keydown', (event) => {
      if (window.innerWidth > 768) {
        if (event.code === 'Space') {
          event.preventDefault(); // Prevent page scroll
        } else if (event.code === 'Enter' || event.code === 'NumpadEnter') {
          if (isComplete) {
            // Enter key triggers GO button when ready
            playMedHit();
            generateNewPhrase();
            isComplete = false;
            pageTurnPlayed = false; // Reset page-turn flag for next cycle
            
            generateBtn.classList.remove('ready', 'filling');
            generateBtn.style.transition = 'none';
            generateBtn.style.setProperty('--fill-width', '0%');
            
            generateBtn.offsetHeight; // Force reflow
            generateBtn.style.transition = '';
            
            startAutoFill();
          }
        }
      }
    });

    // Add document-level click listener to advance progress from anywhere on screen
    document.addEventListener('click', (event) => {
      // Only advance progress if we're not complete and not clicking on the generate button
      // (to avoid double advancement when clicking the button)
      if (!isComplete && event.target !== generateBtn && !generateBtn.contains(event.target)) {
        advanceProgress();
      }
    });

    // --- AUDIO FUNCTIONS ---
    const backgroundMusic = document.getElementById('background-music');
    const childsModeMusic = new Audio('audio/music/swoon.mp3');
    let mainMusicPosition = 0; // Track position of main music when paused
    let childsMusicPosition = 0; // Track position of child's mode music when paused
    
    // Typewriter sound effects
    let typewriterSounds = [];
    let currentTypewriterSoundIndex = 0;
    const typewriterVolume = 0.3; // Volume for typewriter sounds
 
    // Simple numbered playlist system
    const totalSongs = 5; // Update this number when you add more songs
    const playlist = [];
    
    // Generate playlist: 1.mp3, 2.mp3, 3.mp3, etc.
    for (let i = 1; i <= totalSongs; i++) {
      playlist.push(`audio/music/${i}.mp3`);
    }
    
    /**
     * Initialize page sounds
     */
    const initializePageSounds = () => {
      // Load page-turn sounds for when GO button becomes active
      const pageTurnSound1 = new Audio('audio/typewriter/page-turn.mp3');
      pageTurnSound1.volume = 1;
      pageTurnSound1.preload = 'auto';
      
      const pageTurnSound2 = new Audio('audio/typewriter/page-turn-2.mp3');
      pageTurnSound2.volume = 1;
      pageTurnSound2.preload = 'auto';
      
      window.pageTurnSounds = [pageTurnSound1, pageTurnSound2];
      
      // Load med-hit sound for when user clicks GO
      const medHitSound = new Audio('audio/typewriter/med-hit.mp3');
      medHitSound.volume = 0.2;
      medHitSound.preload = 'auto';
      window.medHitSound = medHitSound;
      
    };
    
    /**
     * Play random page-turn sound for GO button
     */
    const playPageTurn = () => {
      if (window.pageTurnSounds && window.pageTurnSounds.length > 0) {
        const randomIndex = Math.floor(Math.random() * window.pageTurnSounds.length);
        const sound = window.pageTurnSounds[randomIndex];
        if (sound.currentTime > 0.1) {
          sound.currentTime = 0;
        }
        sound.play().catch(err => {});
      }
    };
    
    /**
     * Play med-hit sound when user clicks GO
     */
    const playMedHit = () => {
      if (window.medHitSound) {
        if (window.medHitSound.currentTime > 0.1) {
          window.medHitSound.currentTime = 0;
        }
        window.medHitSound.play().catch(err => {});
      }
    };
    
    /**
     * Play sound for backspace (30% louder, no volume calculations)
     */
    const playBackspaceSound = (backspaceCount, totalBackspaces) => {
      if (!window.typewriterSounds || window.typewriterSounds.length === 0) return;
      
      const sound = window.typewriterSounds[Math.floor(Math.random() * window.typewriterSounds.length)];
      
      if (sound.currentTime > 0.1) {
        sound.currentTime = 0;
      }
      
      // 30% louder for backspace
      const originalVolume = sound.volume;
      sound.volume = Math.min(originalVolume * 1.3, 1.0);
      sound.play().catch(() => {});
      sound.volume = originalVolume; // Reset volume
    };
    
    
    const initializeTypewriterSounds = () => {
      // Load all three very-soft sounds for variety
      window.typewriterSounds = [
        new Audio('audio/typewriter/very-soft-hit.mp3'),
        new Audio('audio/typewriter/very-soft-hit-2.mp3'),
        new Audio('audio/typewriter/very-soft-hit-3.mp3')
      ];
      
      // Set volumes
      window.typewriterSounds.forEach(sound => {
        sound.volume = typewriterVolume;
        sound.preload = 'auto';
      });
      
      // Load carriage return and bell sounds separately
      window.carriageSound = new Audio('audio/typewriter/carriage-return.mp3');
      window.carriageSound.volume = typewriterVolume * 0.5;
      window.carriageSound.preload = 'auto';
      
      window.bellSound = new Audio('audio/typewriter/bell.mp3');
      window.bellSound.volume = typewriterVolume * 0.7;
      window.bellSound.preload = 'auto';
    };
    
    /**
     * Plays a typewriter sound effect with realistic variation
     */
    const playTypewriterSound = (char) => {
      if (!window.typewriterSounds || window.typewriterSounds.length === 0) return;
      
      const sound = window.typewriterSounds[Math.floor(Math.random() * window.typewriterSounds.length)];
      
      if (sound.currentTime > 0.1) {
        sound.currentTime = 0;
      }
      sound.play().catch(() => {});
    };
    
    /**
     * Plays the carriage return sound
     */
    const playCarriageSound = () => {
      if (!window.carriageSound) return;
      
      // Play the carriage return sound (with error handling)
      if (window.carriageSound.currentTime > 0.1) {
        window.carriageSound.currentTime = 0;
      }
      window.carriageSound.play().catch(err => {
        // Ignore audio play errors (browser restrictions, etc.)
      });
    };
    
    /**
     * Plays the bell sound
     */
    const playBellSound = () => {
      if (!window.bellSound) return;
      
      // Play the bell sound (with error handling)
      if (window.bellSound.currentTime > 0.1) {
        window.bellSound.currentTime = 0;
      }
      window.bellSound.play().catch(err => {
        // Ignore audio play errors (browser restrictions, etc.)
      });
    };
    
    let currentSongIndex = 0;
    
    /**
     * Loads and plays the current song
     */
    const loadAndPlayCurrentSong = () => {
      const currentSong = playlist[currentSongIndex];
      
      // Clear existing sources
      backgroundMusic.innerHTML = '';
      
      // Add new source
      const source = document.createElement('source');
      source.src = currentSong;
      source.type = 'audio/mpeg';
      backgroundMusic.appendChild(source);
      
      // Load and play
      backgroundMusic.load();
      return backgroundMusic.play().then(() => {
        if (!CONFIG.noConsole) {
          console.log(`üéµ Now playing song ${currentSongIndex + 1}/${playlist.length}: ${currentSong}`);
        }
        updatePlayingState();
      }).catch(e => {
        if (!CONFIG.noConsole) {
          console.log('Failed to play song:', currentSong);
        }
        throw e; // Re-throw to allow caller to handle
      });
    };
    
    /**
     * Plays the next song in the playlist
     */
    const playNextSong = () => {
      currentSongIndex = (currentSongIndex + 1) % playlist.length;
      loadAndPlayCurrentSong();
    };
    
    // Listen for music play/pause events
    backgroundMusic.addEventListener('play', updatePlayingState);
    backgroundMusic.addEventListener('pause', updatePlayingState);
    childsModeMusic.addEventListener('play', updatePlayingState);
    childsModeMusic.addEventListener('pause', updatePlayingState);
    backgroundMusic.addEventListener('ended', playNextSong);
    
    /**
     * Initializes background music
     */
    const initializeAudio = () => {
      if (!CONFIG.backgroundMusic || playlist.length === 0) return;
      
      backgroundMusic.volume = CONFIG.musicVolume;
      
      // Start music on first user interaction
      const startMusic = () => {
        if (CONFIG.backgroundMusic) {
          loadAndPlayCurrentSong().catch(err => {
            if (!CONFIG.noConsole) {
              console.log('Audio failed to play after user interaction');
            }
          });
        }
        // Remove the event listeners after first interaction
        document.removeEventListener('click', startMusic);
        document.removeEventListener('keydown', startMusic);
      };
      
      // Add event listeners for first user interaction
      document.addEventListener('click', startMusic);
      document.addEventListener('keydown', startMusic);
    };
    

    // --- INITIALIZATION ---
     // Initialize child's mode toggle
     updatechildsModeToggle();
     
     // Set initial childs-mode class on body
     if (CONFIG.childsMode) {
       document.body.classList.add('childs-mode');
     } else {
       document.body.classList.remove('childs-mode');
     }
    
    // Initialize background music
    initializeAudio();
    
    // Initialize typewriter sounds
    initializeTypewriterSounds();
    initializePageSounds();
    
    // Add spacebar keyup listener for progress advancement (desktop only)
    document.addEventListener('keyup', (event) => {
      if (window.innerWidth > 768 && event.code === 'Space') {
        if (!isComplete) {
          // Spacebar keyup advances progress when filling
          advanceProgress();
        }
      }
    });
    
    // Start the auto-fill animation when the page loads
    startAutoFill();

  </script>

</body>
</html>