<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pure and Infinite Joy Machine</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>❤️</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body class="bg-gray-100 text-black min-h-screen p-4">
  <!-- BGM -->
  <audio id="background-music" preload="auto">
    Your browser does not support the audio element.
  </audio>
  
  <div class="flex flex-col items-center justify-start min-h-screen space-y-6 pt-16">
    <!-- Header -->
    <h1 class="text-2xl font-semibold text-gray-900">Pure and Infinite Joy Machine</h1>

    <!-- Generate Btn -->
    <button id="generate-btn" class="font-bold py-2 px-6 rounded-lg text-sm transition-colors duration-300 w-full max-w-md">
      <span class="btn-text"></span>
    </button>

    <!-- Phrase Display Zone -->
    <div class="flex flex-col sm:flex-row items-center justify-center w-full max-w-md relative">
      <p id="phrase-output" class="text-xl font-medium text-gray-900 text-center"></p>
      <button id="copy-btn" class="opacity-0 transition-opacity duration-200 p-2 rounded sm:absolute sm:-right-10 mt-2">
        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
        </svg>
      </button>
    </div>

    <!-- Toast -->
    <div id="toast" class="text-center text-gray-500 text-lg opacity-0 transition-opacity duration-100 pointer-events-none">
      copied
    </div>
  </div>

  <!-- Control Btn -->
  <div class="fixed bottom-4 left-4 flex items-center space-x-2 z-10">
    <!-- Mute Btn -->
    <button id="mute-btn" class="w-8 h-8 flex items-center justify-center">
      <img id="mute-icon" src="images/volume.png" alt="Volume" class="w-6 h-6 transition-all duration-300">
    </button>
    
    <!-- Dark Mode -->
    <button id="dark-mode-btn" class="w-8 h-8 flex items-center justify-center">
      <img id="dark-mode-icon" src="images/moon.png" alt="Dark Mode" class="w-6 h-6 transition-all duration-300">
    </button>
  </div>

  <!-- child's mode Toggle -->
  <div class="fixed bottom-4 right-4 flex items-center space-x-3 z-10">
    <label for="childs-mode-toggle" class="text-sm text-gray-600 cursor-pointer">
      Child's Mode
    </label>
    <button id="childs-mode-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 p-1">
      <span id="childs-mode-slider" class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
    </button>
  </div>

  <script src="lists.js"></script>
  
  <script>
    const CONFIG = {
      fillDuration: 50000, 
      updateInterval: 50, 
      advanceAmount: 0.012,
      typoChance: 0.025,
      typoCorrectionChance: .96,
      doubleBeastChance: 0.85,
      tripleBeastChance: 0.60,
      doubleCandyChance: .5,
      fuckingChance: 0.13,
      thinkingPauseChance: 0.20, 
      allCapsChance: 0.07,
      skipSpaceChance: 0.00,
      swapLettersChance: 0.008,
      childsMode: false,
      backgroundMusic: true,
      musicVolume: 0.08,
      tagChance: 0.3, 
      darkMode: false, 
      noConsole: false,
      testMode: false,
      typingSpeedMultiplier: .8,
      typingSpeed: { //+ nums, - typing DUH
        space: { min: 13, max: 38 },
        vowel: { min: 18, max: 51 },
        consonant: { min: 20, max: 55 },
        number: { min: 50, max: 65 },
        punctuation: { min: 42, max: 80 }
      }
    };

    // formats DUH
    // join words w/ pause markers DUH
    const joinWords = (...words) => {
        const nonEmptyWords = words.filter(word => word && word.trim() !== '');
        return nonEmptyWords.join(' | '); // | = pause DUH
    };
    
    const formats = [

            (i, b, n, c, a, f) => joinWords(i), 
            (i, b, n, c, a, f) => joinWords(n),
            (i, b, n, c, a, f) => joinWords(c), (i, b, n, c, a, f) => joinWords(c),
            // (i, b, n, c, a, f) => joinWords(f),
            
            // (i, b, n, c, a, f) => joinWords(i, f),
            (i, b, n, c, a, f) => joinWords(a, n), (i, b, n, c, a, f) => joinWords(a, n),
            (i, b, n, c, a, f) => joinWords(c, n), 
            (i, b, n, c, a, f) => joinWords(c, n),
            // (i, b, n, c, a, f) => joinWords(n, f),

            (i, b, n, c, a, f) => joinWords(i, b, f),
            // (i, b, n, c, a, f) => joinWords(i, c, f),
            (i, b, n, c, a, f) => joinWords(i, n, f),
            (i, b, n, c, a, f) => joinWords(i, a, n), 
            // (i, b, n, c, a, f) => joinWords(i, a, n),
            // (i, b, n, c, a, f) => joinWords(b, n, f),
            // (i, b, n, c, a, f) => joinWords(b, c, f),
            (i, b, n, c, a, f) => joinWords(b, a, n),
            (i, b, n, c, a, f) => joinWords(a, n, f),
            // (i, b, n, c, a, f) => joinWords(c, a, n),
        
            (i, b, n, c, a, f) => joinWords(i, n, c, f),
            // (i, b, n, c, a, f) => joinWords(i, c, b, f),
            (i, b, n, c, a, f) => joinWords(i, c, n, f),
            (i, b, n, c, a, f) => joinWords(i, a, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, c, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, n),
            // (i, b, n, c, a, f) => joinWords(b, a, n, f),
            // (i, b, n, c, a, f) => joinWords(b, c, n, f),
            // (i, b, n, c, a, f) => joinWords(b, a, c, f),

            (i, b, n, c, a, f) => joinWords(i, b, a, c, f),
            // (i, b, n, c, a, f) => joinWords(b, a, c, f, i),
            (i, b, n, c, a, f) => joinWords(i, c, a, n, f),
            (i, b, n, c, a, f) => joinWords(i, a, n, c, f),
            (i, b, n, c, a, f) => joinWords(i, a, c, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, c, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, n, f),
            (i, b, n, c, a, f) => joinWords(b, c, a, n, i),
            // (i, b, n, c, a, f) => joinWords(i, n, a, c, f),
            (i, b, n, c, a, f) => joinWords(i, a, c, b, f),
            (i, b, n, c, a, f) => joinWords(i, a, b, n, f),
            // (i, b, n, c, a, f) => joinWords(c, i, b, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, c, a, n, f),
            // (i, b, n, c, a, f) => joinWords(c, i, b, a, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, n, c, f),
            // (i, b, n, c, a, f) => joinWords(b, i, c, a, n, f),
            (i, b, n, c, a, f) => joinWords(b, a, n, c, f, i),
            // (i, b, n, c, a, f) => joinWords(i, c, b, a, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, c, n, f),
            (i, b, n, c, a, f) => joinWords(i, b, a, c, n, f)


            ];
        
    

    // QWERTY layout for typos DUH
    const QWERTY_MAP = {
        'q': ['w'], 'w': ['q', 'e'], 'e': ['w', 'r'],
        'r': ['e', 't'], 't': ['r', 'y'], 'y': ['t', 'u'],
        'u': ['y', 'i'], 'i': ['u', 'o'], 'o': ['i', 'p'],
        'p': ['o'], 'a': ['s'], 's': ['a', 'd'],
        'd': ['s', 'f'], 'f': ['d', 'g'], 'g': ['f', 'h'],
        'h': ['g', 'j'], 'j': ['h', 'k'], 'k': ['j', 'l'],
        'l': ['k'], 'z': ['x'], 'x': ['z', 'c'],
        'c': ['x', 'v'], 'v': ['c', 'b'], 'b': ['v', 'n'],
        'n': ['b', 'm'], 'm': ['n']
    };
    
    // typo cache for speed DUH
    const TYPO_CACHE = new Map();
    const getTypoChar = (char) => {
        if (TYPO_CACHE.has(char)) {
            return TYPO_CACHE.get(char);
        }
        
        const adjacent = QWERTY_MAP[char.toLowerCase()];
        if (!adjacent || adjacent.length === 0) {
            TYPO_CACHE.set(char, char);
            return char;
        }
        
        const randomTypo = adjacent[Math.floor(Math.random() * adjacent.length)];
        const result = char === char.toUpperCase() ? randomTypo.toUpperCase() : randomTypo;
        TYPO_CACHE.set(char, result);
        return result;
    };

    // DOM stuff DUH
    const generateBtn = document.getElementById('generate-btn');
    const phraseOutput = document.getElementById('phrase-output');
    const copyBtn = document.getElementById('copy-btn');
    const toast = document.getElementById('toast');
    const childsModeToggle = document.getElementById('childs-mode-toggle');
    const childsModeSlider = document.getElementById('childs-mode-slider');
    let fillInterval;
    let currentFill = 0;
    const totalSteps = CONFIG.fillDuration / CONFIG.updateInterval; // Total number of steps
    let isComplete = false;
    let pageTurnPlayed = false;
    let typingTimeouts = []; // Track active typing timeouts to prevent conflicts
    let isTyping = false; // Track if typing animation is currently active
    
    // timeout system prevents repeats DUH
    let itemTimeouts = {
        intro: new Map(), // item -> timeout count DUH
        beast: new Map(),
        noun: new Map(),
        candy: new Map(),
        adjective: new Map(),
        finale: new Map(),
        tag: new Map()
    };

    // functions DUH
    /**
     * Clear all active typing timeouts to prevent conflicts my guy
     */
    const clearTypingTimeouts = () => {
      typingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
      typingTimeouts = [];
      isTyping = false;
    };

    /**
     * awwww yeah add item to the timeout list with dynamic cooldown based on list size my guy
     */
    const addItemToTimeout = (listType, item) => {
      const listTypes = ['intro', 'beast', 'noun', 'candy', 'adjective', 'finale', 'tag'];
      const listIndex = listTypes.indexOf(listType);
      
      if (listIndex !== -1 && window.wordLists && window.wordLists[listIndex]) {
        // cooldown = list size - 1 DUH
        const cooldownDuration = window.wordLists[listIndex].length - 1;
        itemTimeouts[listType].set(item, cooldownDuration);
      } else {
        // fallback if broken DUH
        itemTimeouts[listType].set(item, 25);
      }
    };

    /**
     * -1s all timeout counters + removes expired items my guy
     */
    const decrementTimeouts = () => {
      Object.keys(itemTimeouts).forEach(listType => {
        const timeoutMap = itemTimeouts[listType];
        const itemsToRemove = [];
        
        timeoutMap.forEach((count, item) => {
          const newCount = count - 1;
          if (newCount <= 0) {
            itemsToRemove.push(item);
          } else {
            timeoutMap.set(item, newCount);
          }
        });
        
        itemsToRemove.forEach(item => timeoutMap.delete(item));
      });
    };

    /**
     * Gets avail items from a list, EXCLUSING those on timeout my guy
     */
    const getAvailableItems = (listIndex) => {
      const listTypes = ['intro', 'beast', 'noun', 'candy', 'adjective', 'finale', 'tag'];
      const listType = listTypes[listIndex];
      const allItems = window.wordLists[listIndex];
      const timeoutMap = itemTimeouts[listType];
      
      // filter out timed out items DUH
      const availableItems = allItems.filter(item => !timeoutMap.has(item));
      
      // if all timed out use all anyway DUH
      return availableItems.length > 0 ? availableItems : allItems;
    };

    /**
     * Apply letter swapping
     * Returns BOTH the processed phrase + a set of words that were letter-swapped
     */
    const applyLetterSwapping = (phrase) => {
      // split phrase into words DUH
      const words = phrase.split(' ');
      const swappedWords = new Set(); // Track which words were letter-swapped slime
      
      // process each word DUH
      const processedWords = words.map(word => {
        // skip words w/ numbers or symbols DUH
        if (/\d/.test(word) || /[^a-zA-Z]/.test(word)) {
          return word;
        }
        
        // need 3+ chars to swap DUH
        if (word.length < 3) {
          return word; // Not enough letters to swap oh noooo
        }
        
        // calc prob based on length DUH
        // base 1% for short words, +1% per extra char DUH
        const baseChance = CONFIG.swapLettersChance; // 1%
        const lengthBonus = Math.max(0, word.length - 4) * 0.01; // +1% per letter over 4
        const finalChance = baseChance + lengthBonus;
        
        // check if should swap letters DUH
        if (Math.random() >= finalChance) {
          return word; // No swapping this word okayyyy?
        }
        
        // convert to array DUH
        const chars = word.split('');
        
        // find adjacent pairs (not first/last) DUH
        const eligiblePairs = [];
        for (let i = 1; i < chars.length - 2; i++) {
          eligiblePairs.push(i); // i and i+1 will be swapped
        }
        
        // need 1+ adjacent pair DUH
        if (eligiblePairs.length === 0) {
          return word; // Not enough letters to swap oh noooo
        }
        
        // pick random pair DUH
        const pairIndex = eligiblePairs[Math.floor(Math.random() * eligiblePairs.length)];
        const pos1 = pairIndex;
        const pos2 = pairIndex + 1;
        
        // swap chars DUH
        const temp = chars[pos1];
        chars[pos1] = chars[pos2];
        chars[pos2] = temp;
        
        const swappedWord = chars.join('');
        swappedWords.add(swappedWord); // Track this word as letter-swapped slime
        
        return swappedWord;
      });
      
      return {
        phrase: processedWords.join(' '),
        swappedWords: swappedWords
      };
    };

    /**
     * Generates a random "weeeeee" with 4-10 'e's weeeeee
     * @returns {string} A random weeeeee string weeeeeeee
     */
    const generateWeeeeee = () => {
      const eCount = Math.floor(Math.random() * 7) + 4; // 4-10 'e's
      return 'we' + 'e'.repeat(eCount);
    };

    /**
     * Replaces NSFW words with alts if child's mode enabled
     * @param {string} text The text to filter
     * @returns {string} The filtered text
     */
    const filterNSFW = (text) => {
      if (!CONFIG.childsMode) return text;
      
      let filteredText = text;
      
      // first pass: custom replacements DUH
      // sort by length (longest first) DUH
      const replacementWords = Object.keys(window.childsModeReplacements)
        .sort((a, b) => b.length - a.length);
      
      replacementWords.forEach(originalWord => {
        const replacement = window.childsModeReplacements[originalWord];
        // replace w/ custom replacement DUH
        const regex = new RegExp(`\\b${originalWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
        filteredText = filteredText.replace(regex, replacement);
      });
      
      // second pass: NSFW -> weeeeee DUH
      // sort by length (longest first) DUH
      const sortedNsfwWords = window.nsfwWords
        .filter(word => !window.childsModeReplacements.hasOwnProperty(word.toLowerCase())) // skip custom replacements DUH
        .sort((a, b) => b.length - a.length);
      
      sortedNsfwWords.forEach(nsfwWord => {
        // create case-insensitive regex DUH
        const regex = new RegExp(`\\b${nsfwWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
        filteredText = filteredText.replace(regex, generateWeeeeee());
      });
      
      return filteredText;
    };

    /**
     * Selects random item from a given array and processes brackets (RANDOM!)
     * @param {Array} arr The array to pick from.
     * @returns {*} A random item from the array with brackets processed.
     */
    const getRandomItem = (arr) => {
      const rawItem = arr[Math.floor(Math.random() * arr.length)];
      const { result } = processBrackets(rawItem);
      return result;
    };

    /**
     * Creates a word tracking object for detailed format display
     */
    const createWordTracking = (original) => ({
        original,
        final: original,
        modifications: [],
        addons: [],
        alternates: [],
        hardStop: false,
        beastStop: false
    });

    /**
     * Processes alt in a word (content in parentheses with / separators) okayyyy?
     */
    const processAlternates = (word) => {
        let result = word;
        let alternates = [];
        const alternatesRegex = /\(([^)]*(?:\/[^)]*)+)\)/g;
        let match;
        
        while ((match = alternatesRegex.exec(word)) !== null) {
            const alternatesContent = match[1];
            const options = alternatesContent.split('/').map(opt => opt.trim());
            
            // check if option has custom prob DUH
            const hasCustomProbabilities = options.some(opt => opt.includes(',') && /,\s*\d*\.?\d+$/.test(opt));
            
            let selectedOption;
            if (hasCustomProbabilities) {
                // parse options w/ probs DUH
                const weightedOptions = [];
                options.forEach(opt => {
                    const probMatch = opt.match(/^(.+),\s*(\d*\.?\d+)$/);
                    if (probMatch) {
                        const content = probMatch[1].trim();
                        const weight = parseFloat(probMatch[2]);
                        weightedOptions.push({ content, weight });
                    } else {
                        weightedOptions.push({ content: opt, weight: 1 });
                    }
                });
                
                const totalWeight = weightedOptions.reduce((sum, opt) => sum + opt.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const opt of weightedOptions) {
                    random -= opt.weight;
                    if (random <= 0) {
                        selectedOption = opt.content;
                        break;
                    }
                }
            } else {
                const selectedIndex = Math.floor(Math.random() * options.length);
                selectedOption = options[selectedIndex];
                alternates.push(`alt: ${selectedOption}`);
            }
            
            result = result.replace(match[0], selectedOption);
        }
        
        return { result, alternates };
    };

    /**
     * Processes brackets (add-ons) in a word from innermost to outermost yummyyy
     */
    const processBrackets = (word) => {
        let result = word;
        let addons = [];
        let hasHardStop = false;
        let hasBeastStop = false;
        
        // check for *B* at end of word DUH
        if (result.includes(', *B*') || result.endsWith(' *B*')) {
            hasBeastStop = true;
            // remove *B* marker DUH
            result = result.replace(/,\s*\*B\*|\s*\*B\*$/, '');
        }
        
        let changed = true;
        while (changed) {
            changed = false;
            
            // find innermost bracket DUH
            const innermostBracketRegex = /\[([^\[\]]+)\]/;
            const bracketMatch = result.match(innermostBracketRegex);
            
            if (bracketMatch) {
                const bracketContent = bracketMatch[1];
                
                
                // check for custom prob DUH
                const probabilityMatch = bracketContent.match(/^(.+),\s*(\d*\.?\d+)(?:,\s*\*F\*|\*B\*)?$/);
                let probability = 0.5;
                let contentToProcess = bracketContent;
                
                if (probabilityMatch) {
                    contentToProcess = probabilityMatch[1].trim();
                    probability = parseFloat(probabilityMatch[2]);
                } else {
                    // check if just content w/ *F* or *B* DUH
                    const hardStopMatch = bracketContent.match(/^(.+),\s*\*F\*$/);
                    const beastStopMatch = bracketContent.match(/^(.+),\s*\*B\*$/);
                    if (hardStopMatch) {
                        contentToProcess = hardStopMatch[1].trim();
                        probability = 0.5; // default probability
                    } else if (beastStopMatch) {
                        contentToProcess = beastStopMatch[1].trim();
                        probability = 0.5; // default probability
                    }
                }
                
                const shouldInclude = Math.random() < probability;
                
                if (shouldInclude) {
                    // clean content before adding DUH
                    let cleanContent = contentToProcess;
                    
                    // check for *F* before removing DUH
                    if (bracketContent.includes('*F*')) {
                        hasHardStop = true;
                    }
                    
                    // check for *B* before removing DUH
                    if (bracketContent.includes('*B*')) {
                        hasBeastStop = true;
                    }
                    
                    // remove *F* marker DUH
                    cleanContent = cleanContent.replace(/\*F\*/g, '');
                    
                    // remove remaining prob info DUH
                    cleanContent = cleanContent.replace(/,\s*\d*\.?\d+\s*$/, '');
                    cleanContent = cleanContent.replace(/,\s*\d*\.?\d+\s*,/, ',');
                    
                    result = result.replace(bracketMatch[0], cleanContent);
                    
                    
                    // track bracket content w/ prob DUH
                    addons.push(bracketContent);
                } else {
                    result = result.replace(bracketMatch[0], '');
                    
                }
                
                changed = true;
            }
        }
        
        return { result: result.replace(/\s+/g, ' ').trim(), addons, hasHardStop, hasBeastStop };
    };
    


    /**
     * Clean up phrase, by removing unwanted start/end words owo
     */
    // precompiled regexes for cleanup DUH
    const BAD_START_WORDS = ['and', 'or', 'for', 'with', 'in', 'by way of', 'using', 'ok', 'plus', 'compilation','emits'];
    const BAD_END_WORDS = ['fucking', 'crazy', 'and', 'POV:', ','];
    const BAD_START_REGEXES = BAD_START_WORDS.map(w => new RegExp(`^${w}\\s+`, 'i'));
    const BAD_END_REGEXES = BAD_END_WORDS.map(w => new RegExp(`\\s+${w}$`, 'i'));

    const cleanPhrase = (phrase) => {
        // remove unwanted start words DUH
        for (const rx of BAD_START_REGEXES) {
            phrase = phrase.replace(rx, '');
        }
        
        // remove unwanted end words DUH
        for (const rx of BAD_END_REGEXES) {
            phrase = phrase.replace(rx, '');
        }
        
        // clean up extra spaces DUH
        phrase = phrase.replace(/^\s+/, '').replace(/\s+$/, '').replace(/\s+/g, ' ');
        
        return phrase;
    };

    /**
     * Adds a tag to a phrase slime
     */
    const addTagToPhrase = (phrase, tag) => {
        // if tag starts w/ period, remove space DUH
        if (tag.startsWith('.')) {
            return `${phrase.trim()}${tag}`;
        }
        // otherwise add w/ normal spacing DUH
        return `${phrase} ${tag}`;
    };

    /**
     * Generates a new phrase and displays it weeeeee
     */
    const generateNewPhrase = () => {
        // hide copy btn while generating DUH
        copyBtn.classList.add('opacity-0');
        
        // clear existing typing animations DUH
        clearTypingTimeouts();
        
        // stop existing audio DUH
        stopWordAudio();
        stopDeleteAudio();
        
        // define possible formats DUH
        // helper func to join words DUH
        const joinWords = (...words) => words.filter(word => word && word.trim() !== '').join(' ');
        
        
    
        
        // pick random format DUH
        const randomFormat = formats[Math.floor(Math.random() * formats.length)];
        const formatIndex = formats.indexOf(randomFormat);
        
        // create readable format string DUH
        const getFormatString = (format) => {
            const testResult = format('I', 'B', 'N', 'C', 'A', 'F');
            return testResult;
        };
        const formatString = getFormatString(randomFormat);
        
        // determine which word types needed DUH
        const needsIntro = formatString.includes('I');
        const needsBeast = formatString.includes('B');
        const needsNoun = formatString.includes('N');
        const needsCandy = formatString.includes('C');
        const needsAdjective = formatString.includes('A');
        const needsFinale = formatString.includes('F');
        
        // only get items for needed types DUH
        const intro = needsIntro ? getAvailableItems(0)[Math.floor(Math.random() * getAvailableItems(0).length)] : null;
        const beast = needsBeast ? getAvailableItems(1)[Math.floor(Math.random() * getAvailableItems(1).length)] : null;
        const noun = needsNoun ? getAvailableItems(2)[Math.floor(Math.random() * getAvailableItems(2).length)] : null;
        const candy = needsCandy ? getAvailableItems(3)[Math.floor(Math.random() * getAvailableItems(3).length)] : null;
        const adjective = needsAdjective ? getAvailableItems(4)[Math.floor(Math.random() * getAvailableItems(4).length)] : null;
        const finale = needsFinale ? getAvailableItems(5)[Math.floor(Math.random() * getAvailableItems(5).length)] : null;
        
        // track words & mods for display DUH
        const wordTracking = {
            intro: intro ? createWordTracking(intro) : null,
            beast: beast ? createWordTracking(beast) : null,
            noun: noun ? createWordTracking(noun) : null,
            candy: candy ? createWordTracking(candy) : null,
            adjective: adjective ? createWordTracking(adjective) : null,
            finale: finale ? createWordTracking(finale) : null
        };
        
        // process each word w/ tracking DUH
        const processWordWithTracking = (word, tracking) => {
            // process alternates first DUH
            const { result: afterAlternates, alternates } = processAlternates(word);
            
            // process brackets DUH
            const { result, addons, hasHardStop, hasBeastStop } = processBrackets(afterAlternates);
            
            // update tracking DUH
            tracking.final = result;
            tracking.addons = addons;
            tracking.alternates = alternates;
            tracking.hardStop = hasHardStop;
            tracking.beastStop = hasBeastStop;
            tracking.original = word; // Store original for display purposes
            
            // hard stop handling done after DUH
            
            return result;
        };
        
        // process each word (only needed ones) DUH
        let processedIntro = intro ? processWordWithTracking(intro, wordTracking.intro) : '';
        let processedBeast = beast ? processWordWithTracking(beast, wordTracking.beast) : '';
        let processedNoun = noun ? processWordWithTracking(noun, wordTracking.noun) : '';
        let processedCandy = candy ? processWordWithTracking(candy, wordTracking.candy) : '';
        let processedAdjective = adjective ? processWordWithTracking(adjective, wordTracking.adjective) : '';
        let processedFinale = finale ? processWordWithTracking(finale, wordTracking.finale) : '';
        
        // init tag vars DUH
        let tag = null;
        let processedTag = '';
        let tagTracking = null;
        
        
        
        // apply random duplications DUH
        let finalBeast = processedBeast;
        let finalNoun = processedNoun;
        let finalCandy = processedCandy;
        
        // track additional items for timeout DUH
        let additionalItemsUsed = [];
        
        // track how many fuckings added DUH
        let fucksGiven = 0;
        
        // check for beast stop after first beast DUH
        if (needsBeast && wordTracking.beast?.beastStop) {
            // beast stop triggered - skip duplications DUH
            // continue w/ normal processing DUH
        } else if (needsBeast && !wordTracking.beast?.hardStop && Math.random() < CONFIG.doubleBeastChance) {
            // get different beast (avoid dupes) DUH
            let availableSecondBeasts = getAvailableItems(1).filter(item => item !== beast);
            // if no beasts available, fallback DUH
            if (availableSecondBeasts.length === 0) {
                availableSecondBeasts = window.wordLists[1].filter(item => item !== beast);
            }
            const secondBeast = availableSecondBeasts[Math.floor(Math.random() * availableSecondBeasts.length)];
            additionalItemsUsed.push({type: 'beast', item: secondBeast});
            
            const secondBeastTracking = createWordTracking(secondBeast);
            const secondBeastProcessed = processWordWithTracking(secondBeast, secondBeastTracking);
            finalBeast = `${processedBeast} ${secondBeastProcessed}`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('double');
            // merge add-ons from both beasts DUH
            wordTracking.beast.addons = [...wordTracking.beast.addons, ...secondBeastTracking.addons];
            wordTracking.beast.alternates = [...wordTracking.beast.alternates, ...secondBeastTracking.alternates];
            
            // check for beast stop after second beast DUH
            if (wordTracking.beast.beastStop || secondBeastTracking.beastStop) {
                // beast stop triggered - skip third beast DUH
            } else if (!wordTracking.beast?.hardStop && !secondBeastTracking?.hardStop && Math.random() < CONFIG.tripleBeastChance) {
                // get different third beast (avoid dupes) DUH
                let availableThirdBeasts = getAvailableItems(1).filter(item => item !== beast && item !== secondBeast);
                // if no beasts available, fallback DUH
                if (availableThirdBeasts.length === 0) {
                    availableThirdBeasts = window.wordLists[1].filter(item => item !== beast && item !== secondBeast);
                }
                const thirdBeast = availableThirdBeasts[Math.floor(Math.random() * availableThirdBeasts.length)];
                additionalItemsUsed.push({type: 'beast', item: thirdBeast});
                
                const thirdBeastTracking = createWordTracking(thirdBeast);
                const thirdBeastProcessed = processWordWithTracking(thirdBeast, thirdBeastTracking);
                finalBeast = `${finalBeast} ${thirdBeastProcessed}`;
                wordTracking.beast.final = finalBeast;
                wordTracking.beast.modifications.push('triple');
                // merge add-ons from third beast DUH
                wordTracking.beast.addons = [...wordTracking.beast.addons, ...thirdBeastTracking.addons];
                wordTracking.beast.alternates = [...wordTracking.beast.alternates, ...thirdBeastTracking.alternates];
            }
        }

        // 50% chance to add second candy DUH
        if (needsCandy && !wordTracking.candy?.hardStop && Math.random() < CONFIG.doubleCandyChance) {
            // get different candy (avoid dupes) DUH
            let availableSecondCandies = getAvailableItems(3).filter(item => item !== candy);
            // if no candies available, fallback DUH
            if (availableSecondCandies.length === 0) {
                availableSecondCandies = window.wordLists[3].filter(item => item !== candy);
            }
            const secondCandy = availableSecondCandies[Math.floor(Math.random() * availableSecondCandies.length)];
            additionalItemsUsed.push({type: 'candy', item: secondCandy});
            
            const secondCandyTracking = createWordTracking(secondCandy);
            const secondCandyProcessed = processWordWithTracking(secondCandy, secondCandyTracking);
            finalCandy = `${processedCandy} ${secondCandyProcessed}`;
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('double');
            // merge add-ons from both candies DUH
            wordTracking.candy.addons = [...wordTracking.candy.addons, ...secondCandyTracking.addons];
            wordTracking.candy.alternates = [...wordTracking.candy.alternates, ...secondCandyTracking.alternates];
        }
        
        // 10% chance to add fucking before beast DUH
        if (needsBeast && Math.random() < CONFIG.fuckingChance) {
            finalBeast = `fucking ${finalBeast}`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('fucking');
            fucksGiven++;
        }
        
        // 10% chance to add fucking after beasts DUH
        if (needsBeast && Math.random() < 0.1) {
            finalBeast = `${finalBeast} fucking`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('fucking-after');
            fucksGiven++;
        }
        
        // 10% chance to add fucking before noun DUH
        if (needsNoun && Math.random() < CONFIG.fuckingChance) {
            finalNoun = `fucking ${finalNoun}`;
            wordTracking.noun.final = finalNoun;
            wordTracking.noun.modifications.push('fucking');
            fucksGiven++;
        }
        
        // 10% chance to add fucking before candy DUH
        if (needsCandy && Math.random() < CONFIG.fuckingChance) {
            finalCandy = `fucking ${finalCandy}`;
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('fucking');
            fucksGiven++;
        }
        
        // apply all caps to non-beast items DUH
        if (needsIntro && Math.random() < CONFIG.allCapsChance) {
            processedIntro = processedIntro.toUpperCase();
            wordTracking.intro.final = processedIntro;
            wordTracking.intro.modifications.push('all-caps');
        }
        
        if (needsNoun && Math.random() < CONFIG.allCapsChance) {
            finalNoun = finalNoun.toUpperCase();
            wordTracking.noun.final = finalNoun;
            wordTracking.noun.modifications.push('all-caps');
        }
        
        if (needsCandy && Math.random() < CONFIG.allCapsChance) {
            finalCandy = finalCandy.toUpperCase();
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('all-caps');
        }
        
        if (needsAdjective && Math.random() < CONFIG.allCapsChance) {
            processedAdjective = processedAdjective.toUpperCase();
            wordTracking.adjective.final = processedAdjective;
            wordTracking.adjective.modifications.push('all-caps');
        }
        
        if (needsFinale && Math.random() < CONFIG.allCapsChance) {
            processedFinale = processedFinale.toUpperCase();
            wordTracking.finale.final = processedFinale;
            wordTracking.finale.modifications.push('all-caps');
        }
        
        // check for hard stops before generating DUH
        let hasHardStop = false;
        let hardStopWord = '';
        
        // combined debug output for used types DUH
        // create words obj in order DUH
        const wordsInOrder = {};
        
        // add words in order if used DUH
        if (needsIntro) {
            let introDisplay = processedIntro;
            if (wordTracking.intro?.hardStop) introDisplay += ', *F*';
            if (wordTracking.intro?.beastStop) introDisplay += ', *B*';
            wordsInOrder.intro = introDisplay;
        }
        if (needsBeast) {
            let beastDisplay = finalBeast;
            if (wordTracking.beast?.hardStop) beastDisplay += ', *F*';
            if (wordTracking.beast?.beastStop) beastDisplay += ', *B*';
            wordsInOrder.beast = beastDisplay;
        }
        if (needsNoun) {
            let nounDisplay = finalNoun;
            if (wordTracking.noun?.hardStop) nounDisplay += ', *F*';
            if (wordTracking.noun?.beastStop) nounDisplay += ', *B*';
            wordsInOrder.noun = nounDisplay;
        }
        if (needsCandy) {
            let candyDisplay = finalCandy;
            if (wordTracking.candy?.hardStop) candyDisplay += ', *F*';
            if (wordTracking.candy?.beastStop) candyDisplay += ', *B*';
            wordsInOrder.candy = candyDisplay;
        }
        if (needsAdjective) {
            let adjectiveDisplay = processedAdjective;
            if (wordTracking.adjective?.hardStop) adjectiveDisplay += ', *F*';
            if (wordTracking.adjective?.beastStop) adjectiveDisplay += ', *B*';
            wordsInOrder.adjective = adjectiveDisplay;
        }
        if (needsFinale) {
            let finaleDisplay = processedFinale;
            if (wordTracking.finale?.hardStop) finaleDisplay += ', *F*';
            if (wordTracking.finale?.beastStop) finaleDisplay += ', *B*';
            wordsInOrder.finale = finaleDisplay;
        }
        
        const debugOutput = {
            format: `${formatIndex + 1} (${formatString})`,
            fucksGiven: fucksGiven,
            words: wordsInOrder
        };
        
        // check word types for hard stops DUH
        if (needsIntro && wordTracking.intro?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedIntro;
        } else if (needsBeast && wordTracking.beast?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalBeast;
        } else if (needsNoun && wordTracking.noun?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalNoun;
        } else if (needsCandy && wordTracking.candy?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalCandy;
        } else if (needsAdjective && wordTracking.adjective?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedAdjective;
        } else if (needsFinale && wordTracking.finale?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedFinale;
        }
        
        // generate phrase w/ selected format DUH
        let phrase;
        if (hasHardStop) {
            // if hard stop, find trigger & stop DUH
            // respect actual format selected DUH
            let stopAfterIntro = needsIntro && wordTracking.intro?.hardStop;
            let stopAfterBeast = needsBeast && wordTracking.beast?.hardStop;
            let stopAfterNoun = needsNoun && wordTracking.noun?.hardStop;
            let stopAfterCandy = needsCandy && wordTracking.candy?.hardStop;
            let stopAfterAdjective = needsAdjective && wordTracking.adjective?.hardStop;
            let stopAfterFinale = needsFinale && wordTracking.finale?.hardStop;
            
            // if hard stop, respect format order DUH
            // determine which word triggered stop DUH
            let hardStopType = null;
            if (stopAfterIntro) hardStopType = 'intro';
            else if (stopAfterBeast) hardStopType = 'beast';
            else if (stopAfterNoun) hardStopType = 'noun';
            else if (stopAfterCandy) hardStopType = 'candy';
            else if (stopAfterAdjective) hardStopType = 'adjective';
            else if (stopAfterFinale) hardStopType = 'finale';
            
            // parse format string for order DUH
            const formatOrder = [];
            // split by spaces & map to types DUH
            const formatParts = formatString.split(' ');
            formatParts.forEach(part => {
                switch(part) {
                    case 'I': formatOrder.push('intro'); break;
                    case 'B': formatOrder.push('beast'); break;
                    case 'N': formatOrder.push('noun'); break;
                    case 'C': formatOrder.push('candy'); break;
                    case 'A': formatOrder.push('adjective'); break;
                    case 'F': formatOrder.push('finale'); break;
                }
            });
            
            // find position of hard stop word DUH
            const stopIndex = formatOrder.indexOf(hardStopType);
            
            
            // determine which words to include DUH
            let includeIntro = needsIntro && (stopIndex === -1 || formatOrder.indexOf('intro') <= stopIndex);
            let includeBeast = needsBeast && (stopIndex === -1 || formatOrder.indexOf('beast') <= stopIndex);
            let includeNoun = needsNoun && (stopIndex === -1 || formatOrder.indexOf('noun') <= stopIndex);
            let includeCandy = needsCandy && (stopIndex === -1 || formatOrder.indexOf('candy') <= stopIndex);
            let includeAdjective = needsAdjective && (stopIndex === -1 || formatOrder.indexOf('adjective') <= stopIndex);
            let includeFinale = needsFinale && (stopIndex === -1 || formatOrder.indexOf('finale') <= stopIndex);
            
            
            // build phrase w/ included words DUH
            phrase = randomFormat(
                includeIntro ? processedIntro : '',
                includeBeast ? finalBeast : '',
                includeNoun ? finalNoun : '',
                includeCandy ? finalCandy : '',
                includeAdjective ? processedAdjective : '',
                includeFinale ? processedFinale : ''
            );
        } else {
            // normal phrase generation DUH
            phrase = randomFormat(processedIntro, finalBeast, finalNoun, finalCandy, processedAdjective, processedFinale);
        }
        
        // clean up consecutive fuckings DUH
        phrase = phrase.replace(/\*[FB]\*/g, ''); // Remove markers first
        phrase = phrase.replace(/\b(fucking\s+)+fucking\b/gi, 'fucking'); // Remove consecutive fuckings
        
        // clean up phrase formatting DUH
        phrase = cleanPhrase(phrase);
        
        // apply child's mode filtering DUH
        phrase = filterNSFW(phrase);
        
        // apply letter swapping chaos DUH
        const letterSwapResult = applyLetterSwapping(phrase);
        phrase = letterSwapResult.phrase;
        const swappedWords = letterSwapResult.swappedWords;
        
        // check for tag addition DUH
        // tags appear after finales or stops DUH
        const shouldAddTag = (needsFinale || hasHardStop) && Math.random() < CONFIG.tagChance;
        
        if (shouldAddTag) {
            // get random tag from available DUH
            const availableTags = getAvailableItems(6); // Tags are at index 6
            if (availableTags.length > 0) {
                tag = availableTags[Math.floor(Math.random() * availableTags.length)];
                tagTracking = createWordTracking(tag);
                
                // process tag word DUH
                processedTag = processWordWithTracking(tag, tagTracking);
                
                // check if prev word was all-caps DUH
                let lastWordTypeWasAllCaps = false;
                
                if (hasHardStop) {
                    // determine which word triggered stop DUH
                    if (needsIntro && wordTracking.intro?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.intro?.modifications?.includes('all-caps') || false;
                    } else if (needsBeast && wordTracking.beast?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.beast?.modifications?.includes('all-caps') || false;
                    } else if (needsNoun && wordTracking.noun?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.noun?.modifications?.includes('all-caps') || false;
                    } else if (needsCandy && wordTracking.candy?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.candy?.modifications?.includes('all-caps') || false;
                    } else if (needsAdjective && wordTracking.adjective?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.adjective?.modifications?.includes('all-caps') || false;
                    } else if (needsFinale && wordTracking.finale?.hardStop) {
                        lastWordTypeWasAllCaps = wordTracking.finale?.modifications?.includes('all-caps') || false;
                    }
                } else {
                    // normal completion - check finale caps DUH
                    if (needsFinale) {
                        lastWordTypeWasAllCaps = wordTracking.finale?.modifications?.includes('all-caps') || false;
                    }
                }
                
                // apply all-caps to tag if prev was DUH
                if (lastWordTypeWasAllCaps) {
                    processedTag = processedTag.toUpperCase();
                    tagTracking.final = processedTag;
                    tagTracking.modifications.push('all-caps-inherited');
                }
                
                // add to timeout system DUH
                addItemToTimeout('tag', tag); // Add the tag item to the tag list
                additionalItemsUsed.push({type: 'tag', item: tag});
                
                // apply child's mode filter to tag DUH
                processedTag = filterNSFW(processedTag);
                
                // add tag to end of phrase DUH
                phrase = addTagToPhrase(phrase, processedTag);
                
                // add tag to debug output DUH
                let tagDisplay = processedTag;
                if (tagTracking?.hardStop) tagDisplay += ', *F*';
                if (tagTracking?.beastStop) tagDisplay += ', *B*';
                debugOutput.words.tag = tagDisplay;
            }
        }
        
        // log debug output after processing DUH
        // if (!CONFIG.noConsole) {
          // console.log('🎪', debugOutput);
        // }
        
        // add used items to timeout list DUH
        if (needsIntro && intro) addItemToTimeout('intro', intro);
        if (needsBeast && beast) addItemToTimeout('beast', beast);
        if (needsNoun && noun) addItemToTimeout('noun', noun);
        if (needsCandy && candy) addItemToTimeout('candy', candy);
        if (needsAdjective && adjective) addItemToTimeout('adjective', adjective);
        if (needsFinale && finale) addItemToTimeout('finale', finale);
        if (tag) addItemToTimeout('tag', tag);
        
        // add additional beasts & candies used DUH
        additionalItemsUsed.forEach(({type, item}) => {
            addItemToTimeout(type, item);
        });
        
        // decrement timeout counters DUH
        decrementTimeouts();
        
        // animate typing phrase DUH
        typeOutPhrase(phrase, swappedWords);
        
        // detailed format display DUH
        // const formatDisplay = document.getElementById('format-display');
        // if (formatDisplay) {
        //     const detailedFormat = generateDetailedFormatString(phrase, randomFormat, wordTracking, formatIndex + 1);
        //     formatDisplay.textContent = `Format ${formatIndex + 1}: ${detailedFormat}`;
        // }
        
        // copy btn shown after typing DUH
    };
    
    // helper func for detailed format string DUH
    const generateDetailedFormatString = (phrase, format, wordTracking, formatNumber) => {
        // create test phrase for format structure DUH
        const testPhrase = format('I', 'B', 'N', 'C', 'A', 'F');
        const testParts = testPhrase.split(' ');
        
        // map test parts to types DUH
        const typeMap = {};
        testParts.forEach((part, index) => {
            if (part === 'I') typeMap[index] = 'I';
            else if (part === 'B') typeMap[index] = 'B';
            else if (part === 'N') typeMap[index] = 'N';
            else if (part === 'C') typeMap[index] = 'C';
            else if (part === 'A') typeMap[index] = 'A';
            else if (part === 'F') typeMap[index] = 'F';
        });
        
        let result = [];
        let literalWords = [];
        
        // process each part of test phrase DUH
        testParts.forEach((testPart, testIndex) => {
            if (testPart === 'I' || testPart === 'B' || testPart === 'N' || testPart === 'C' || testPart === 'A' || testPart === 'F') {
                // flush accumulated literal words DUH
                if (literalWords.length > 0) {
                    result.push(`"${literalWords.join(' ')}"`);
                    literalWords = [];
                }
                
                const type = typeMap[testIndex];
                const wordData = wordTracking[type === 'I' ? 'intro' : type === 'B' ? 'beast' : type === 'N' ? 'noun' : type === 'C' ? 'candy' : type === 'A' ? 'adjective' : 'finale'];
                
                // use final processed word DUH
                let displayWord = wordData.final;
                
                // quotes around fucking DUH
                if (wordData.modifications.includes('fucking')) {
                    displayWord = displayWord.replace(/^fucking /, '"fucking" ');
                }
                if (wordData.modifications.includes('fucking-after')) {
                    displayWord = displayWord.replace(/ fucking$/, ' "fucking"');
                }
                
                // remove (*F*) + (*B*) markers DUH
                displayWord = displayWord.replace(/\*F\*/g, '');
                displayWord = displayWord.replace(/\*B\*/g, '');
                
                // add back brackets for included add-ons DUH
                if (wordData.addons.length > 0) {
                    wordData.addons.forEach(addon => {
                        const cleanAddon = addon.replace(/,\s*\d*\.?\d+$/, '');
                        // find addon content & wrap in brackets DUH
                        if (wordData.final.includes(cleanAddon)) {
                            displayWord = displayWord.replace(cleanAddon, `[${cleanAddon}]`);
                        }
                    });
                }
                
                // add back alts that were selected DUH
                if (wordData.alternates.length > 0) {
                    wordData.alternates.forEach(alt => {
                        const cleanAlt = alt.replace('alt: ', '');
                        // find alt & slap in parens DUH
                        if (wordData.final.includes(cleanAlt)) {
                            displayWord = displayWord.replace(cleanAlt, `(${cleanAlt})`);
                        }
                    });
                }
                
                // add processed word as single unit DUH
                result.push(displayWord);
                
                // add type annotation after brackets DUH
                result[result.length - 1] += ` (${type})`;
                
                // *F* if word triggered hard stop DUH
                if (wordData.hardStop) {
                    result[result.length - 1] += ' *F*';
                }
                
                // *B* marker if word triggered beast stop DUH
                if (wordData.beastStop) {
                    result[result.length - 1] += ' *B*';
                }
                
                // add modification annotations DUH
                if (wordData.modifications.includes('triple')) {
                    result[result.length - 1] += ' (3)';
                } else if (wordData.modifications.includes('double')) {
                    result[result.length - 1] += ' (2)';
                }
            } else {
                // This is literal text - accumulate it DUH
                literalWords.push(testPart);
            }
        });
        
        // Flush any remaining literal words DUH
        if (literalWords.length > 0) {
            result.push(`"${literalWords.join(' ')}"`);
        }
        
        return result.join(' ');
    };
    
    /**
     * Updates button state classes and text DUH
     */
    const updateButtonState = (state) => {
      generateBtn.classList.remove('filling', 'ready');
      generateBtn.classList.add(state);
      
      // Update button text based on state DUH
      const btnText = generateBtn.querySelector('.btn-text');
      if (state === 'filling') {
        btnText.textContent = '';
      } else if (state === 'ready') {
        btnText.textContent = 'GO';
      }
    };

    /**
      * child's mode toggle appearance DUH
      */
     const updatechildsModeToggle = () => {
       const on = CONFIG.childsMode;
       childsModeToggle.classList.toggle('bg-pink-500', on);
       childsModeToggle.classList.toggle('bg-gray-200', !on);
       childsModeSlider.classList.toggle('translate-x-5', on);
       childsModeSlider.classList.toggle('translate-x-0', !on);
     };


     /**
      * Toggles child's mode DUH
      */
     const togglechildsMode = () => {
       CONFIG.childsMode = !CONFIG.childsMode;
       updatechildsModeToggle();
       
       // music switching DUH
       if (CONFIG.backgroundMusic) {
         if (CONFIG.childsMode) {
           // switch to lullaby DUH
           if (!backgroundMusic.paused) {
             mainMusicPosition = backgroundMusic.currentTime;
             backgroundMusic.pause();
           }
           childsModeMusic.volume = CONFIG.musicVolume;
           childsModeMusic.currentTime = childsMusicPosition;
           childsModeMusic.loop = true;
           childsModeMusic.play().catch(err => {
             if (!CONFIG.noConsole) {
               console.log('Child\'s mode music failed to play');
             }
           });
         } else {
           // Switch back to main music DUH
           if (!childsModeMusic.paused) {
             childsMusicPosition = childsModeMusic.currentTime;
             childsModeMusic.pause();
           }
           backgroundMusic.currentTime = mainMusicPosition;
           if (backgroundMusic.paused) {
             backgroundMusic.play().catch(err => {
               if (!CONFIG.noConsole) {
                 console.log('Main music failed to resume');
               }
             });
           }
         }
       }
       
       // add/remove childs-mode class DUH
       document.body.classList.toggle('childs-mode', CONFIG.childsMode);
       
       // Update GO button text if it's currently ready DUH
       if (generateBtn.classList.contains('ready')) {
         const btnText = generateBtn.querySelector('.btn-text');
           btnText.textContent = 'GO';
       }
     };

     /**
      * Toggles dark mode DUH
      */
     const toggleDarkMode = () => {
       CONFIG.darkMode = !CONFIG.darkMode;
       
       if (CONFIG.darkMode) {
         // Enable dark mode DUH
         document.body.classList.add('dark');
         darkModeIcon.src = 'images/sun.png';
         darkModeIcon.alt = 'Light Mode';
         
         // Switch to dark vol icons DUH
         if (backgroundMusic.muted) {
           muteIcon.src = 'images/mute-dark.png';
         } else {
           muteIcon.src = 'images/volume-dark.png';
         }
       } else {
         // Disable dark mode DUH
         document.body.classList.remove('dark');
         darkModeIcon.src = 'images/moon.png';
         darkModeIcon.alt = 'Dark Mode';
         
         // Switch to light vol icons DUH
         if (backgroundMusic.muted) {
           muteIcon.src = 'images/mute.png';
         } else {
           muteIcon.src = 'images/volume.png';
         }
       }
     };

     /**
      * Toggles BGM DUH
      */
     const toggleMusic = () => {
       if (backgroundMusic.muted) {
         // unmute DUH
         backgroundMusic.muted = false;
         childsModeMusic.muted = false;
         muteIcon.src = CONFIG.darkMode ? 'images/volume-dark.png' : 'images/volume.png';
         muteIcon.alt = 'Volume';
         muteBtn.classList.remove('muted');
         updatePlayingState();
       } else {
         // mute DUH
         backgroundMusic.muted = true;
         childsModeMusic.muted = true;
         muteIcon.src = CONFIG.darkMode ? 'images/mute-dark.png' : 'images/mute.png';
         muteIcon.alt = 'Muted';
         muteBtn.classList.add('muted');
         muteBtn.classList.remove('playing');
       }
    };
    
    /**
     * Shows toast DUH
     */
    const showToast = () => {
      toast.classList.remove('opacity-0');
      setTimeout(() => {
        toast.classList.add('opacity-0');
      }, 2000);
    };
    
    /**
     * Animate typing out a phrase DUH
     */
    const typeOutPhrase = (phrase, swappedWords = new Set()) => {
        // check phrase is defined DUH
        if (!phrase || typeof phrase !== 'string') {
            console.error('typeOutPhrase called with invalid phrase:', phrase);
            return;
        }
        
        // clear existing typing animations DUH
        clearTypingTimeouts();
        
        // Clear the phrase output first DUH
        phraseOutput.textContent = '';
        
        // Reset font size to default DUH
        phraseOutput.style.fontSize = '';

        // check if shirley temple DUH
        const isSpecialSmallText = phrase.includes('meet me at the darian gap at 0-300');
        
        // Set size for shirley temple DUH
        if (isSpecialSmallText) {
            phraseOutput.style.setProperty('font-size', '20px', 'important');
            console.log('Special small text detected - setting to 20px');
            console.log('Computed font size:', window.getComputedStyle(phraseOutput).fontSize);
        }

        // Mark typing as active DUH
        isTyping = true;
        
        let currentIndex = 0;
        let typingSpeed = 1.0; // Dynamic speed multiplier
        let lastCharTime = 0;
        let soundCounter = 0; // Counter for playing sounds on every other letter
        let pendingCorrections = []; // Track typos that need correction
        let displayedText = ''; // Track what's actually displayed
        let hasActiveTypo = false; // Prevent multiple typos
        
        let rafId = null;
        const scheduleNextChar = (delay) => {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(() => {
                const timeoutId = setTimeout(typeNextChar, delay);
                typingTimeouts.push(timeoutId);
            });
        };

        const typeNextChar = () => {
            if (currentIndex < phrase.length) {
                const char = phrase[currentIndex];
                const prevChar = currentIndex > 0 ? phrase[currentIndex - 1] : '';
                
                // check for random effects DUH
                let actualChar = char;
                
                // skip spaces between words DUH
                if (char === ' ' && CONFIG.skipSpaceChance > 0 && Math.random() < CONFIG.skipSpaceChance) {
                    // skip this space DUH
                    currentIndex++;
                    scheduleNextChar(Math.round(getBaseDelay(char, prevChar)));
                    return;
                }
                
                // first/last letter immune to effects DUH
                let isFirstLetterOfWord = false;
                let isLastLetterOfWord = false;
                
                if (char !== ' ') {
                    // check if prev char is space/start DUH
                    isFirstLetterOfWord = (currentIndex === 0 || phrase[currentIndex - 1] === ' ');
                    
                    // check if next char is space/end DUH
                    isLastLetterOfWord = (currentIndex === phrase.length - 1 || phrase[currentIndex + 1] === ' ');
                    
                    // play word-length typing sound DUH
                    if (isFirstLetterOfWord) {
                        // Find the word length and check for CAPS DUH
                        let wordEnd = currentIndex;
                        while (wordEnd < phrase.length && phrase[wordEnd] !== ' ') {
                            wordEnd++;
                        }
                        const wordLength = wordEnd - currentIndex;
                        const word = phrase.substring(currentIndex, wordEnd);
                        const hasCapitals = /[A-Z]/.test(word);
                        playWordTypingSound(wordLength, hasCapitals);
                        
                    }
                }
                
                
                // check if should add typo DUH
                // check if word was letter-swapped DUH
                let currentWord = '';
                if (char !== ' ') {
                    // Find the current word being typed DUH
                    let wordStart = currentIndex;
                    while (wordStart > 0 && phrase[wordStart - 1] !== ' ') {
                        wordStart--;
                    }
                    let wordEnd = currentIndex;
                    while (wordEnd < phrase.length && phrase[wordEnd] !== ' ') {
                        wordEnd++;
                    }
                    currentWord = phrase.substring(wordStart, wordEnd);
                }
                
                // check if at last word DUH
                const remainingPhrase = phrase.substring(currentIndex + 1).trim();
                const wordsLeft = remainingPhrase.split(' ').filter(word => word.length > 0);
                const isLastWord = wordsLeft.length <= 1;
                
                let shouldMakeTypo = !hasActiveTypo && 
                                   Math.random() < CONFIG.typoChance && 
                                   char.match(/[a-zA-Z]/) && 
                                   !swappedWords.has(currentWord) &&
                                   !isLastWord; // Last word is immune from typos DUH
                
                if (shouldMakeTypo) {
                    // make typo based on QWERTY DUH
                    actualChar = getTypoChar(char);
                    hasActiveTypo = true; // Prevent more typos
                }
                
                // check for pause marker DUH
                if (actualChar === '|') {
                    // add random pause 0-300ms DUH
                    const pauseDelay = Math.random() * 300;
                    currentIndex++; // Increment index to move past the |
                    
                    // skip trailing space after | DUH
                    if (currentIndex < phrase.length && phrase[currentIndex] === ' ') {
                        currentIndex++;
                    }
                    
                    setTimeout(() => {
                        typeNextChar();
                    }, pauseDelay);
                    return; // Skip displaying the | character
                }
                
                // add char (orig or typo) DUH
                displayedText += actualChar;
                
                // word-based audio handled at word level DUH
                
                // play typewriter sound for letters DUH
                // COMMENTED OUT - TRYING NEW TYPING AUDIO
                /*
                if (actualChar.match(/[a-zA-Z ]/)) {
                    if (actualChar === ' ') {
                        // spacebar: random sound 30% louder DUH
                        if (window.typewriterSounds && window.typewriterSounds.length > 0) {
                            const sound = window.typewriterSounds[Math.floor(Math.random() * window.typewriterSounds.length)];
                            if (sound.currentTime > 0.1) {
                                sound.currentTime = 0;
                            }
                            
                            // 60% louder for spacebar DUH
                            const originalVolume = sound.volume;
                            const boosted = Math.min(originalVolume * 1.6, 1.0);
                            if (boosted !== originalVolume) {
                                sound.volume = boosted;
                                sound.play().catch(() => {});
                                sound.volume = originalVolume; // Reset volume
                            } else {
                                sound.play().catch(() => {});
                            }
                        }
                    } else {
                        // letters use soft-hit sounds DUH
                        soundCounter++;
                        if (soundCounter % 3 === 0) {
                            // check if capital letter DUH
                            if (actualChar === actualChar.toUpperCase() && actualChar.match(/[A-Z]/)) {
                                // capitals 100% louder DUH
                                if (window.typewriterSounds && window.typewriterSounds.length > 0) {
                                    const sound = window.typewriterSounds[Math.floor(Math.random() * window.typewriterSounds.length)];
                                    if (sound.currentTime > 0.1) {
                                        sound.currentTime = 0;
                                    }
                                    
                                    const originalVolume = sound.volume;
                                    const boosted = Math.min(originalVolume * 2, 1.0);
                                    if (boosted !== originalVolume) {
                                        sound.volume = boosted;
                                        sound.play().catch(() => {});
                                        sound.volume = originalVolume; // Reset volume
                                    } else {
                                        sound.play().catch(() => {});
                                    }
                                }
                            } else {
                                playTypewriterSound(actualChar);
                            }
                            
                            // 50% chance skip ahead DUH
                            if (Math.random() < 0.5) {
                                soundCounter++;
                            }
                        }
                    }
                }
                */
                
                phraseOutput.textContent = displayedText;
                currentIndex++;
                
                // check if at end of word DUH
                const isEndOfWord = char === ' ' || currentIndex >= phrase.length;
                
                // check word timing for carriage DUH
                if (char === ' ' && currentIndex < phrase.length) {
                    // just typed space, check what's left DUH
                    const remainingPhrase = phrase.substring(currentIndex).trim();
                    const wordsLeft = remainingPhrase.split(' ').filter(word => word.length > 0);
                    
                    if (wordsLeft.length === 1) {
                        // last word - play carriage sound DUH
                        playCarriageSound();
                    }
                }
                
                if (isEndOfWord && hasActiveTypo) {
                    // finished word w/ typo - check correction DUH
                    // calc correction chance by position DUH
                    let correctionChance = CONFIG.typoCorrectionChance; // Default 80%
                    
                    // check if last word in phrase DUH
                    const isLastWord = currentIndex >= phrase.length;
                    
                    let wordEndIndex, wordStartIndex, displayedWordEnd, displayedWordStartIndex;
                    
                    if (isLastWord) {
                        // special handling for last word DUH
                        wordEndIndex = phrase.length;
                        wordStartIndex = wordEndIndex - 1;
                        while (wordStartIndex > 0 && phrase[wordStartIndex - 1] !== ' ') {
                            wordStartIndex--;
                        }
                        
                        // for displayed text: use full length DUH
                        displayedWordEnd = displayedText.length;
                        displayedWordStartIndex = displayedWordEnd - 1;
                        while (displayedWordStartIndex > 0 && displayedText[displayedWordStartIndex - 1] !== ' ') {
                            displayedWordStartIndex--;
                        }
                    } else {
                        // normal handling for non-last words DUH
                        wordEndIndex = char === ' ' ? currentIndex - 1 : currentIndex;
                        wordStartIndex = wordEndIndex - 1;
                        while (wordStartIndex > 0 && phrase[wordStartIndex - 1] !== ' ') {
                            wordStartIndex--;
                        }
                        
                        // for displayed text: find last word DUH
                        displayedWordEnd = displayedText.length;
                        if (displayedText[displayedText.length - 1] === ' ') {
                            displayedWordEnd = displayedText.length - 1;
                        }
                        displayedWordStartIndex = displayedWordEnd - 1;
                        while (displayedWordStartIndex > 0 && displayedText[displayedWordStartIndex - 1] !== ' ') {
                            displayedWordStartIndex--;
                        }
                    }
                    
                    // get displayed word (what we typed) DUH
                    const displayedWord = displayedText.substring(displayedWordStartIndex, displayedWordEnd);
                    
                    // get correct word from orig phrase DUH
                    const correctWord = phrase.substring(wordStartIndex, wordEndIndex);
                    
                    // find first char that differs DUH
                    let typoPosition = 0;
                    while (typoPosition < Math.min(displayedWord.length, correctWord.length) && 
                           displayedWord[typoPosition] === correctWord[typoPosition]) {
                        typoPosition++;
                    }
                    
                    // adjust correction chance by position DUH
                    if (typoPosition === 0) {
                        correctionChance = 1.0; // 100% chance for first letter
                    } else if (typoPosition === displayedWord.length - 1) {
                        correctionChance = 1.0; // 100% chance for last letter
                    } else {
                        correctionChance = CONFIG.typoCorrectionChance; // Use CONFIG value for middle letters only
                    }
                    
                    if (Math.random() < correctionChance) {
                        // compare & correct if different DUH
                        if (correctWord !== displayedWord) {
                            correctWordTypo(wordStartIndex, correctWord, displayedWordStartIndex);
                            return; // Don't continue until correction is done
                        }
                    }
                    
                    // reset typo flag for next word DUH
                    hasActiveTypo = false;
                }
                
                // calc realistic delay DUH
                let baseDelay;
                
                if (CONFIG.testMode) {
                    // test mode: super fast typing DUH
                    baseDelay = 1 + Math.random() * 2;
                } else {
                    // normal mode: realistic typing DUH
                    baseDelay = getBaseDelay(actualChar, prevChar);
                
                // apply dynamic speed variation DUH
                typingSpeed += (Math.random() - 0.5) * 0.1; // Gradual speed changes
                typingSpeed = Math.max(0.3, Math.min(1.8, typingSpeed)); // Clamp between 0.3x and 1.8x
                baseDelay *= typingSpeed;
                
                // add natural rhythm variations DUH
                const rhythmVariation = 0.5 + Math.random() * 1.0; // 0.5x to 1.5x variation
                baseDelay *= rhythmVariation;
                }
                
                if (!CONFIG.testMode) {
                    // normal mode: apply realistic effects DUH
                
                // simulate typing bursts DUH
                const timeSinceLastChar = Date.now() - lastCharTime;
                if (timeSinceLastChar > 200) { // After a pause, start with slower typing
                    baseDelay *= 1.5;
                }
                
                // natural pauses after punctuation DUH
                if (prevChar.match(/[.!?]/)) {
                    baseDelay += 33.33 + Math.random() * 66.67; // Extra pause after sentences (3/4ths slower)
                } else if (prevChar.match(/[,;:]/)) {
                    baseDelay += 13.33 + Math.random() * 33.33; // Shorter pause after commas (3/4ths slower)
                }
                
                // occasional longer thinking pauses DUH
                if (Math.random() < CONFIG.thinkingPauseChance) { // 8% chance
                    baseDelay += 100 + Math.random() * 133.33; // Longer thinking pause (3/4ths slower)
                }
                
                // simulate finger fatigue DUH
                const fatigueFactor = 1 + (currentIndex / phrase.length) * 0.04; // Up to 4% slower
                baseDelay *= fatigueFactor;
                
                // word boundaries get slight pauses DUH
                if (char === ' ') {
                    baseDelay += 8 + Math.random() * 13.33; // 3/4ths slower
                    }
                }
                
                lastCharTime = Date.now();
                
                // schedule next char w/ timing DUH
                scheduleNextChar(Math.round(baseDelay));
            } else {
                // typing complete (if no typo) DUH
                if (!hasActiveTypo) {
                    // stop audio when phrase complete DUH
                    stopWordAudio();
                    stopDeleteAudio();
                    
                    // play bell when phrase complete DUH
                    playBellSound();
                    
                    // show copy btn & mark inactive DUH
                copyBtn.classList.remove('opacity-0');
                    isTyping = false;
                    typingTimeouts = []; // Clear the timeout array since we're done
                }
                // if active typo, let correction finish DUH
            }
        };
        
        // func to correct word typo DUH
        const correctWordTypo = (wordStartIndex, correctWord, displayedWordStartIndex) => {
            // get current displayed word DUH
            const displayedWord = displayedText.substring(displayedWordStartIndex).trim();
            
            // find first char that differs DUH
            let typoPosition = 0;
            while (typoPosition < Math.min(displayedWord.length, correctWord.length) && 
                   displayedWord[typoPosition] === correctWord[typoPosition]) {
                typoPosition++;
            }
            
            // if no diff found, just continue DUH
            if (typoPosition >= displayedWord.length && displayedWord.length === correctWord.length) {
                hasActiveTypo = false;
                typeNextChar();
                return;
            }
            
            // calc how many chars to backspace DUH
            const charsToBackspace = displayedWord.length - typoPosition + 1;
            let backspaceCount = 0;
            
            // play delete sound based on count DUH
            playDeleteSound(charsToBackspace);
            
            const backspace = () => {
                if (backspaceCount < charsToBackspace) {
                    displayedText = displayedText.substring(0, displayedText.length - 1);
                    phraseOutput.textContent = displayedText;
                    backspaceCount++;
                    
                    // play soft-hit for backspace DUH
                    // COMMENTED OUT - TRYING NEW TYPING AUDIO
                    /*
                    if (backspaceCount % 2 === 0) {
                        playBackspaceSound(backspaceCount, charsToBackspace);
                    }
                    */
                    
                    // calc backspace delay DUH
                    let delay;
                    if (CONFIG.testMode) {
                        delay = 1; // Super fast backspacing in test mode
                    } else {
                    // slow down approaching typo DUH
                    const progress = backspaceCount / charsToBackspace; // 0 to 1
                    const speedMultiplier = 1 + (progress * 3); // 1x to 4x slower
                    const baseDelay = 15 + Math.random() * 25; // Original fast delay
                        delay = baseDelay * speedMultiplier * (2 - CONFIG.typingSpeedMultiplier); // Apply slowdown and typing speed multiplier
                    }
                    
                    // use optimized timing for backspace DUH
                    if (rafId) cancelAnimationFrame(rafId);
                    rafId = requestAnimationFrame(() => {
                        const timeoutId = setTimeout(backspace, delay);
                        typingTimeouts.push(timeoutId);
                    });
                } else {
                    // continue typing from typo position DUH
                    let continuePosition = wordStartIndex + typoPosition;
                    
                    // special fix for last word DUH
                    // const isLastWord = currentIndex >= phrase.length;
                    // if (isLastWord && typoPosition > 0) {
                    //     continuePosition = wordStartIndex + typoPosition - 1;
                    // }
                    
                    continueTypingFromWordTypo(continuePosition);
                }
            };
            
            backspace();
        };
        
        // func to continue typing from typo DUH
        const continueTypingFromWordTypo = (phrasePosition) => {
            // calc how many letters to retype DUH
            let wordEnd = phrasePosition;
            while (wordEnd < phrase.length && phrase[wordEnd] !== ' ') {
                wordEnd++;
            }
            const lettersToRetype = wordEnd - phrasePosition;
            
            // check if word has capitals DUH
            const word = phrase.substring(phrasePosition, wordEnd);
            const hasCapitals = /[A-Z]/.test(word);
            
            // play sound based on retype count DUH
            if (lettersToRetype > 0) {
                playWordTypingSound(lettersToRetype, hasCapitals);
            }
            
            // update currentIndex to match phrase DUH
            currentIndex = phrasePosition;
            
            // reset typo flag & continue DUH
            hasActiveTypo = false;
            typeNextChar();
        };
        
        // func to continue typing from typo pos DUH
        const continueTypingFromTypo = (typoIndex) => {
            // update currentIndex to match phrase DUH
            currentIndex = typoIndex;
            
            // reset typo flag & continue DUH
            hasActiveTypo = false;
            typeNextChar();
        };
        
        // func to retype word correctly DUH
        const retypeWord = (wordStartIndex, wordEndIndex) => {
            let retypeIndex = wordStartIndex;
            const retype = () => {
                if (retypeIndex < wordEndIndex) {
                    const char = phrase[retypeIndex];
                    displayedText += char;
                    phraseOutput.textContent = displayedText;
                    retypeIndex++;
                    const retypeDelay = CONFIG.testMode ? 1 : ((15 + Math.random() * 25) * (2 - CONFIG.typingSpeedMultiplier)); // Apply typing speed multiplier
                    // use optimized timing for retype DUH
                    if (rafId) cancelAnimationFrame(rafId);
                    rafId = requestAnimationFrame(() => {
                        const timeoutId = setTimeout(retype, retypeDelay);
                        typingTimeouts.push(timeoutId);
                    });
                } else {
                    // word retyped correctly DUH
                    
                    // remove correction from pending DUH
                    const correctionIndex = pendingCorrections.findIndex(c => c.typoIndex === wordStartIndex);
                    if (correctionIndex !== -1) {
                        pendingCorrections.splice(correctionIndex, 1);
                    }
                    
                    // reset active typo flag DUH
                    hasActiveTypo = false;
                    
                    // continue typing from where left off DUH
                    const continueDelay = CONFIG.testMode ? 1 : ((25 + Math.random() * 50) * (2 - CONFIG.typingSpeedMultiplier)); // Apply typing speed multiplier
                    scheduleNextChar(continueDelay);
                }
            };
            
            retype();
        };

        
        // use optimized getTypoChar func DUH
        
        // helper func for base delay DUH
        const getBaseDelay = (char, prevChar) => {
            let baseDelay;
            if (char === ' ') {
                baseDelay = CONFIG.typingSpeed.space.min + Math.random() * (CONFIG.typingSpeed.space.max - CONFIG.typingSpeed.space.min);
            } else if (char.match(/[a-zA-Z]/)) {
                // vowels typed faster than consonants DUH
                if (char.match(/[aeiouAEIOU]/)) {
                    baseDelay = CONFIG.typingSpeed.vowel.min + Math.random() * (CONFIG.typingSpeed.vowel.max - CONFIG.typingSpeed.vowel.min);
                } else {
                    baseDelay = CONFIG.typingSpeed.consonant.min + Math.random() * (CONFIG.typingSpeed.consonant.max - CONFIG.typingSpeed.consonant.min);
                }
            } else if (char.match(/[0-9]/)) {
                baseDelay = CONFIG.typingSpeed.number.min + Math.random() * (CONFIG.typingSpeed.number.max - CONFIG.typingSpeed.number.min);
            } else {
                baseDelay = CONFIG.typingSpeed.punctuation.min + Math.random() * (CONFIG.typingSpeed.punctuation.max - CONFIG.typingSpeed.punctuation.min);
            }
            
            // apply typing speed multiplier DUH
            // lower multiplier = faster typing DUH
            // higher multiplier = slower typing DUH
            return baseDelay * (2 - CONFIG.typingSpeedMultiplier);
        };
        
        // start typing DUH
        lastCharTime = Date.now();
        typeNextChar();
    };


    /**
     * Copies phrase to clipboard
     */
    const copyToClipboard = async () => {
      try {
        await navigator.clipboard.writeText(phraseOutput.textContent);
        showToast();
      } catch (err) {
        // fallback for older browsers DUH
        const textArea = document.createElement('textarea');
        textArea.value = phraseOutput.textContent;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showToast();
      }
    };
    
    /**
     * Starts the auto-fill animation
     */
    // cached progress % to avoid redundant writes DUH
    let lastFillPercent = -1;
    const setFillScalePercent = (percent) => {
      // keep fractional precision DUH
      if (Math.abs(percent - lastFillPercent) >= 0.1) {
        const scale = percent / 100; // Convert percentage to scale (0 to 1)
        generateBtn.style.setProperty('--fill-scale', scale);
        lastFillPercent = percent;
      }
    };

    const startAutoFill = () => {
      if (isComplete) return; // Don't restart if already complete
      // ensure no prev interval running DUH
      if (fillInterval) {
        clearInterval(fillInterval);
        fillInterval = null;
      }
      
      currentFill = 0;
      // temp disable transition for reset DUH
      setFillScalePercent(0);
      updateButtonState('filling');
      
      // test mode: instantly complete bar DUH
      if (CONFIG.testMode) {
        currentFill = totalSteps;
        setFillScalePercent(100);
        updateButtonState('ready');
        isComplete = true;
        return;
      }
      
      // normal mode: gradual fill DUH
      fillInterval = setInterval(() => {
        currentFill++;
        const fillPercentage = (currentFill / totalSteps) * 100;
        setFillScalePercent(fillPercentage);
        
        // play page-turn at 95% (once) DUH
        if (fillPercentage >= 95 && fillPercentage < 96 && !pageTurnPlayed) {
          playPageTurn();
          pageTurnPlayed = true;
        }
        
        // when btn full, mark ready DUH
        if (currentFill >= totalSteps) {
          clearInterval(fillInterval);
          updateButtonState('ready');
          isComplete = true;
        }
      }, CONFIG.updateInterval);
    };

    // event listeners DUH
    // copy btn func - only when visible DUH
    copyBtn.addEventListener('click', (event) => {
      // only copy if btn visible DUH
      const isVisible = !copyBtn.classList.contains('opacity-0');
      if (isVisible) {
        copyToClipboard();
      }
      // if not visible, let click bubble up DUH
    });
    
     // child's mode toggle func DUH
     childsModeToggle.addEventListener('click', togglechildsMode);
     
     // keyboard shortcuts DUH
     document.addEventListener('keydown', (event) => {
       // only trigger if not typing in input DUH
       if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
         switch(event.key.toLowerCase()) {
           case 'm':
             toggleMusic();
             break;
           case 'd':
             toggleDarkMode();
             break;
           case 'c':
             togglechildsMode();
             break;
         }
       }
     });
     
     // mute btn func DUH
    const muteBtn = document.getElementById('mute-btn');
    const muteIcon = document.getElementById('mute-icon');
    
    muteBtn.addEventListener('click', toggleMusic);
    
    // dark mode btn func DUH
    const darkModeBtn = document.getElementById('dark-mode-btn');
    const darkModeIcon = document.getElementById('dark-mode-icon');
    const body = document.body;
    
    darkModeBtn.addEventListener('click', toggleDarkMode);
    
    // func to update playing state DUH
    function updatePlayingState() {
      const mainMusicPlaying = !backgroundMusic.paused && !backgroundMusic.muted;
      const childsMusicPlaying = !childsModeMusic.paused && !childsModeMusic.muted;
      
      if (mainMusicPlaying || childsMusicPlaying) {
        muteBtn.classList.add('playing');
      } else {
        muteBtn.classList.remove('playing');
      }
    }
    
    // func to advance progress bar DUH
    const advanceProgress = () => {
      if (!isComplete) {
        // advance fill by config amount DUH
        const advanceAmount = totalSteps * CONFIG.advanceAmount;
        currentFill = Math.min(currentFill + advanceAmount, totalSteps);
        
        const fillPercentage = (currentFill / totalSteps) * 100;
        setFillScalePercent(fillPercentage);
        
        // play page-turn at 95% (once) DUH
        if (fillPercentage >= 98 && !pageTurnPlayed) {
          playPageTurn();
          pageTurnPlayed = true;
        }
        
        // check if reached completion DUH
        if (currentFill >= totalSteps) {
          clearInterval(fillInterval);
          updateButtonState('ready');
          isComplete = true;
        }
      }
    };

    // add click func to advance/restart DUH
    generateBtn.addEventListener('click', (event) => {
      if (!isComplete) {
        // advance progress when clicked DUH
        advanceProgress();
      } else {
        // btn ready - generate & restart DUH
        playMedHit(); // Play med-hit sound when user clicks GO
        generateNewPhrase();
        isComplete = false;
        pageTurnPlayed = false; // Reset page-turn flag for next cycle
        
        // remove classes & reset fill bar DUH
        generateBtn.classList.remove('ready', 'filling');
        
        // disable transitions for instant reset DUH
        generateBtn.style.transition = 'none';
        setFillScalePercent(0);
        
        // force reflow for immediate reset DUH
        generateBtn.offsetHeight;
        
        // re-enable transitions after reset DUH
        generateBtn.style.transition = '';
        
        startAutoFill();
      }
    });
    
    // add keyboard func (desktop only) DUH
    document.addEventListener('keydown', (event) => {
      if (window.innerWidth > 768) {
        if (event.code === 'Space') {
          event.preventDefault(); // Prevent page scroll
        } else if (event.code === 'Enter' || event.code === 'NumpadEnter') {
          if (isComplete) {
            // enter key triggers GO when ready DUH
            playMedHit();
            generateNewPhrase();
            isComplete = false;
            pageTurnPlayed = false; // Reset page-turn flag for next cycle
            
            generateBtn.classList.remove('ready', 'filling');
            generateBtn.style.transition = 'none';
            setFillScalePercent(0);
            
            generateBtn.offsetHeight; // Force reflow
            generateBtn.style.transition = '';
            
            startAutoFill();
          }
        }
      }
    });

    // add doc-level click to advance progress DUH
    document.addEventListener('click', (event) => {
      // only advance if not complete & not on btn DUH
      // avoid double advancement DUH
      if (!isComplete && event.target !== generateBtn && !generateBtn.contains(event.target)) {
        advanceProgress();
      }
    });

    // audio functions DUH
    const backgroundMusic = document.getElementById('background-music');
    const childsModeMusic = new Audio('audio/music/swoon.mp3');
    let mainMusicPosition = 0; // Track position of main music when paused
    let childsMusicPosition = 0; // Track position of child's mode music when paused
    
    // new word-length typing audio system DUH
    const typingAudioCache = new Map(); // Cache for audio files
    let currentWordAudio = null;
    let currentDeleteAudio = null;
    const soundAlternateState = new Map(); // Track which version to play next for sounds 0-8
    
    // preload typing sounds 0-25 DUH
    const preloadTypingSounds = () => {
      const soundFiles = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 20, 25];
      soundFiles.forEach(num => {
        // load regular version DUH
        const audio = new Audio(`audio/typenum/${num}.mp3`);
        audio.volume = 0.8;
        audio.preload = 'auto';
        typingAudioCache.set(num, audio);
        
        // load alt version for 0-8 DUH
        if (num <= 8) {
          const audioAlt = new Audio(`audio/typenum/${num}.1.mp3`);
          audioAlt.volume = 0.8;
          audioAlt.preload = 'auto';
          typingAudioCache.set(`${num}.1`, audioAlt);
          
          // init alternation state DUH
          soundAlternateState.set(num, false);
        }
      });
      
      // preload delete sounds DUH
      const deleteSounds = ['delete', 'delete2', 'delete3'];
      deleteSounds.forEach(name => {
        const audio = new Audio(`audio/typenum/${name}.mp3`);
        audio.volume = 0.8;
        audio.preload = 'auto';
        typingAudioCache.set(name, audio);
      });
    };
    
    // get sound file # based on word length DUH
    const getSoundForWordLength = (wordLength) => {
      if (wordLength === 1) return 0; // 1 letter uses 0.mp3 (very quiet hit)
      if (wordLength <= 16) return wordLength - 1; // 2-16 letters use sounds 1-15
      if (wordLength <= 20) return 18; // 17-20 letters use 18.mp3
      if (wordLength <= 25) return 20; // 21-25 letters use 20.mp3
      return 25; // 26+ letters use 25.mp3
    };
    
    // play typing sound for word DUH
    const playWordTypingSound = (wordLength, hasCapitals = false) => {
      // stop current word audio DUH
      stopWordAudio();
      
      const soundNum = getSoundForWordLength(wordLength);
      let audioKey = soundNum;
      
      // handle alternation for 0-8 DUH
      if (soundNum <= 8) {
        const useAlternate = soundAlternateState.get(soundNum);
        if (useAlternate) {
          audioKey = `${soundNum}.1`;
        }
        // toggle for next time DUH
        soundAlternateState.set(soundNum, !useAlternate);
      }
      
      const audio = typingAudioCache.get(audioKey);
      if (audio) {
        if (audio.currentTime > 0.1) {
          audio.currentTime = 0;
        }
        
        // boost vol 2x for capitals DUH
        const originalVolume = audio.volume;
        if (hasCapitals) {
          audio.volume = Math.min(originalVolume * 2, 1.0);
        }
        
        currentWordAudio = audio;
        audio.play().catch(() => {});
        
        // reset vol after playing DUH
        if (hasCapitals) {
          audio.volume = originalVolume;
        }
      }
    };
    
    // stop current word audio DUH
    const stopWordAudio = () => {
      if (currentWordAudio) {
        currentWordAudio.pause();
        currentWordAudio.currentTime = 0;
        currentWordAudio = null;
      }
    };
    
    // get delete sound based on char count DUH
    const getDeleteSoundForLength = (deleteLength) => {
      if (deleteLength <= 3) return 'delete';
      if (deleteLength <= 6) return 'delete2';
      return 'delete3'; // 7+ characters
    };
    
    // play delete sound for backspacing DUH
    const playDeleteSound = (deleteLength) => {
      // stop current audio DUH
      stopWordAudio();
      stopDeleteAudio();
      
      const soundName = getDeleteSoundForLength(deleteLength);
      const audio = typingAudioCache.get(soundName);
      if (audio) {
        if (audio.currentTime > 0.1) {
          audio.currentTime = 0;
        }
        
        // play delete sounds at double vol DUH
        const originalVolume = audio.volume;
        audio.volume = Math.min(originalVolume * 2, 1.0);
        
        currentDeleteAudio = audio;
        audio.play().catch(() => {});
        
        // reset vol after playing DUH
        audio.volume = originalVolume;
      }
    };
    
    // stop current delete audio DUH
    const stopDeleteAudio = () => {
      if (currentDeleteAudio) {
        currentDeleteAudio.pause();
        currentDeleteAudio.currentTime = 0;
        currentDeleteAudio = null;
      }
    };
    
    // typewriter sound effects DUH
    let typewriterSounds = [];
    let currentTypewriterSoundIndex = 0;
    const typewriterVolume = 0.3; // vol for typewriter sounds DUH
 
    // simple numbered playlist system DUH
    const totalSongs = 5; // update when adding more songs DUH
    const playlist = [];
    
    // generate playlist: 1-5.mp3 etc DUH
    for (let i = 1; i <= totalSongs; i++) {
      playlist.push(`audio/music/${i}.mp3`);
    }
    
    /**
     * Init page sounds
     */
    const initializePageSounds = () => {
      // load page-turn sounds for GO btn DUH
      const pageTurnSound1 = new Audio('audio/typewriter/page-turn.mp3');
      pageTurnSound1.volume = 1;
      pageTurnSound1.preload = 'auto';
      
      const pageTurnSound2 = new Audio('audio/typewriter/page-turn-2.mp3');
      pageTurnSound2.volume = 1;
      pageTurnSound2.preload = 'auto';
      
      window.pageTurnSounds = [pageTurnSound1, pageTurnSound2];
      
      // load med-hit sound for GO click DUH
      const medHitSound = new Audio('audio/typewriter/med-hit.mp3');
      medHitSound.volume = 0.2;
      medHitSound.preload = 'auto';
      window.medHitSound = medHitSound;
      
    };
    
    /**
     * Play random page-turn sound for GO button
     */
    const playPageTurn = () => {
      if (window.pageTurnSounds && window.pageTurnSounds.length > 0) {
        const randomIndex = Math.floor(Math.random() * window.pageTurnSounds.length);
        const sound = window.pageTurnSounds[randomIndex];
        if (sound.currentTime > 0.1) {
          sound.currentTime = 0;
        }
        sound.play().catch(err => {});
      }
    };
    
    /**
     * med-hit sound when click GO
     */
    const playMedHit = () => {
      if (window.medHitSound) {
        if (window.medHitSound.currentTime > 0.1) {
          window.medHitSound.currentTime = 0;
        }
        window.medHitSound.play().catch(err => {});
      }
    };
    
    /**
     * sound for backspace
     */
    const playBackspaceSound = (backspaceCount, totalBackspaces) => {
      if (!window.typewriterSounds || window.typewriterSounds.length === 0) return;
      
      const sound = window.typewriterSounds[Math.floor(Math.random() * window.typewriterSounds.length)];
      
      if (sound.currentTime > 0.1) {
        sound.currentTime = 0;
      }
      
      // 30% louder for backspace DUH
      const originalVolume = sound.volume;
      const boosted = Math.min(originalVolume * 1.3, 1.0);
      if (boosted !== originalVolume) {
        sound.volume = boosted;
        sound.play().catch(() => {});
        sound.volume = originalVolume; // Reset volume
      } else {
        sound.play().catch(() => {});
      }
    };
    
    
    const initializeTypewriterSounds = () => {
      // load all 3 very-soft sounds DUH
      window.typewriterSounds = [
        new Audio('audio/typewriter/very-soft-hit.mp3'),
        new Audio('audio/typewriter/very-soft-hit-2.mp3'),
        new Audio('audio/typewriter/very-soft-hit-3.mp3')
      ];
      
      // set volumes DUH
      window.typewriterSounds.forEach(sound => {
        sound.volume = typewriterVolume;
        sound.preload = 'auto';
      });
      
      // load carriage return & bell sounds DUH
      window.carriageSound = new Audio('audio/typewriter/carriage-return.mp3');
      window.carriageSound.volume = typewriterVolume * 0.5;
      window.carriageSound.preload = 'auto';
      
      window.bellSound = new Audio('audio/typewriter/bell.mp3');
      window.bellSound.volume = typewriterVolume * 0.7;
      window.bellSound.preload = 'auto';
    };
    
    /**
     * Plays a typewriter sound effect with realistic variation
     */
    const playTypewriterSound = (char) => {
      if (!window.typewriterSounds || window.typewriterSounds.length === 0) return;
      
      const sound = window.typewriterSounds[Math.floor(Math.random() * window.typewriterSounds.length)];
      
      if (sound.currentTime > 0.1) {
        sound.currentTime = 0;
      }
      sound.play().catch(() => {});
    };
    
    /**
     * Plays the carriage return sound
     */
    const playCarriageSound = () => {
      if (!window.carriageSound) return;
      
      // play carriage return sound DUH
      if (window.carriageSound.currentTime > 0.1) {
        window.carriageSound.currentTime = 0;
      }
      window.carriageSound.play().catch(err => {
        // ignore audio play errors DUH
      });
    };
    
    /**
     * Plays the bell sound
     */
    const playBellSound = () => {
      if (!window.bellSound) return;
      
      // play bell sound DUH
      if (window.bellSound.currentTime > 0.1) {
        window.bellSound.currentTime = 0;
      }
      window.bellSound.play().catch(err => {
        // ignore audio play errors DUH
      });
    };
    
    let currentSongIndex = 0;
    
    /**
     * Loads n plays the current song
     */
    // persistent src elem for bg music DUH
    let backgroundMusicSource = null;
    const loadAndPlayCurrentSong = () => {
      const currentSong = playlist[currentSongIndex];
      
      // make sure single persistent <source> DUH
      if (!backgroundMusicSource) {
        backgroundMusicSource = document.createElement('source');
        backgroundMusicSource.type = 'audio/mpeg';
        backgroundMusic.appendChild(backgroundMusicSource);
      }
      backgroundMusicSource.src = currentSong;
      
      // load & play DUH
      backgroundMusic.load();
      return backgroundMusic.play().then(() => {
        // if (!CONFIG.noConsole) {
          // console.log(`🎵 Now playing song ${currentSongIndex + 1}/${playlist.length}: ${currentSong}`);
        // }
        updatePlayingState();
      }).catch(e => {
        if (!CONFIG.noConsole) {
          console.log('Failed to play song:', currentSong);
        }
        throw e; // Re-throw to allow caller to handle
      });
    };
    
    /**
     * Plays the next song
     */
    const playNextSong = () => {
      currentSongIndex = (currentSongIndex + 1) % playlist.length;
      loadAndPlayCurrentSong();
    };
    
    // listen for music play/pause events DUH
    backgroundMusic.addEventListener('play', updatePlayingState);
    backgroundMusic.addEventListener('pause', updatePlayingState);
    childsModeMusic.addEventListener('play', updatePlayingState);
    childsModeMusic.addEventListener('pause', updatePlayingState);
    backgroundMusic.addEventListener('ended', playNextSong);
    
    /**
     * Initializes background music
     */
    const initializeAudio = () => {
      if (!CONFIG.backgroundMusic || playlist.length === 0) return;
      
      backgroundMusic.volume = CONFIG.musicVolume;
      
      // start music on first user interaction DUH
      const startMusic = () => {
        if (CONFIG.backgroundMusic) {
          loadAndPlayCurrentSong().catch(err => {
            if (!CONFIG.noConsole) {
              console.log('Audio failed to play after user interaction');
            }
          });
        }
        // remove event listeners after first interaction DUH
        document.removeEventListener('click', startMusic);
        document.removeEventListener('keydown', startMusic);
      };
      
      // add event listeners for first interaction DUH
      document.addEventListener('click', startMusic);
      document.addEventListener('keydown', startMusic);
    };
    
     // init child's mode toggle DUH
     updatechildsModeToggle();
     
     // set initial childs-mode class DUH
     if (CONFIG.childsMode) {
       document.body.classList.add('childs-mode');
     } else {
       document.body.classList.remove('childs-mode');
     }
    
    // init background music DUH
    initializeAudio();
    
    // init typewriter sounds DUH
    initializeTypewriterSounds();
    initializePageSounds();
    preloadTypingSounds();
    
    // add spacebar listener for progress (desktop) DUH
    /*
    document.addEventListener('keyup', (event) => {
      if (window.innerWidth > 768 && event.code === 'Space') {
        if (!isComplete) {
          // spacebar advances progress when filling DUH
          advanceProgress();
        }
      }
    });
    */
    
    // start auto-fill animation on page load DUH
    startAutoFill();

  </script>

</body>
</html>