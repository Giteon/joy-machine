<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pure and Infinite Joy Machine</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Crimson Text', serif;
    }
    /* Styles for the button fill-up mechanic */
    #generate-btn {
      position: relative;
      overflow: hidden;
      /* Base background for the empty state */
      background-color: #e5e7eb; /* gray-200 */
      transition: background-color 0.3s ease;
      cursor: default; /* Default cursor during loading */
    }
    #generate-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background-color: #cccccc; /* gray for filling state */
      /* Use a CSS variable for the width, controlled by JS */
      width: var(--fill-width, 0%);
      transition: none; /* No transition by default */
    }
    #generate-btn.filling::before {
      transition: width 0.2s ease-out; /* Only animate when filling */
    }
    #generate-btn .btn-text {
        position: relative; /* Ensures text stays on top of the fill */
        z-index: 1;
    }
    /* Button states */
    #generate-btn.filling {
      background-color: #e5e7eb; /* gray-200 */
    }
    #generate-btn.filling .btn-text {
      color: #9ca3af; /* light grey while filling */
    }
    #generate-btn.ready::before {
      background-color: #3b82f6; /* blue-500 - make the fill blue when ready */
    }
    #generate-btn.ready .btn-text {
      color: white; /* white when ready */
    }
    #generate-btn.ready {
      cursor: pointer; /* Pointer cursor only when ready (showing "GO") */
    }

  </style>
</head>
<body class="bg-gray-100 text-black min-h-screen p-4">
  <!-- Background Music -->
  <audio id="background-music" loop preload="auto">
    <source src="audio/Bossamania.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  
  <div class="flex flex-col items-center justify-start min-h-screen space-y-6 pt-16">
    <!-- Header -->
    <h1 class="text-2xl font-semibold text-gray-900">Pure and Infinite Joy Machine</h1>

    <!-- Generate Button -->
    <button id="generate-btn" class="font-bold py-2 px-6 rounded-lg text-sm transition-colors duration-300 w-full max-w-md">
      <span class="btn-text"></span>
    </button>

    <!-- Phrase Display Area -->
    <div class="flex items-center justify-center w-full max-w-md gap-2">
      <p id="phrase-output" class="text-xl font-medium text-gray-900 text-center flex-1"></p>
      <button id="copy-btn" class="opacity-0 transition-opacity duration-200 hover:bg-gray-200 p-2 rounded">
        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
        </svg>
      </button>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="text-center text-gray-500 text-sm opacity-0 transition-opacity duration-100 pointer-events-none">
      copied
    </div>

    <!-- Format Display -->
    <!-- <div id="format-display" class="text-center text-gray-400 text-xs mt-2"></div> -->
  </div>

  <!-- Safe Mode Toggle -->
  <div class="fixed bottom-4 right-4 sm:bottom-4 sm:left-1/2 sm:transform sm:-translate-x-1/2 sm:right-auto flex items-center space-x-3 z-10">
    <label for="safe-mode-toggle" class="text-sm text-gray-600 cursor-pointer">
      Safe Mode
    </label>
    <button id="safe-mode-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 p-1">
      <span id="safe-mode-slider" class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
    </button>
  </div>

  <!-- Import the word lists -->
  <script src="lists.js"></script>
  
  <script>
    // --- CONFIGURATION ---
    const CONFIG = {
      fillDuration: 50000, // 50 seconds in milliseconds
      updateInterval: 50, // Update every 50ms for smooth animation
      advanceAmount: 0.05, // 2% of total steps when clicked
      typoChance: 0.01, // 1% chance per letter
      typoCorrectionChance: 0.95, // 95% chance to catch typo
      doubleBeastChance: 0.5, // 50% chance for two beasts
      tripleBeastChance: 0.3, // 30% chance for three beasts (if already two)
      doubleCandyChance: 0.05, // 5% chance for two candies
      fuckingChance: 0.15, // 15% chance to add "fucking"
      thinkingPauseChance: 0.1, // 10% chance for thinking pause
      allCapsChance: 0.1, // 10% chance for all caps (except beast)
      skipSpaceChance: 0.007, // .7% chance to skip spaces between words
      skipLetterChance: 0.003, // .3% chance to skip letters in words
      doubleLetterChance: 0.002, // .2% chance to double letters in words
      swapLettersChance: 0.005, // .5% chance to swap two letters in phrase
      testMode: false, // Test mode - instant progress bar fill
      safeMode: false, // Safe mode state
      backgroundMusic: true, // Enable background music
      musicVolume: 0.3, // Background music volume (0.0 to 1.0)
      tagChance: 0.1, // 10% chance for tag after finale/hard stop
      typingSpeed: {
        space: { min: 10, max: 26.67 },
        vowel: { min: 13.33, max: 33.33 },
        consonant: { min: 16.67, max: 40 },
        number: { min: 20, max: 46.67 },
        punctuation: { min: 23.33, max: 53.33 }
      }
    };

    // QWERTY keyboard layout for typo generation (only horizontally adjacent keys)
    const QWERTY_MAP = {
        'q': ['w'], 'w': ['q', 'e'], 'e': ['w', 'r'],
        'r': ['e', 't'], 't': ['r', 'y'], 'y': ['t', 'u'],
        'u': ['y', 'i'], 'i': ['u', 'o'], 'o': ['i', 'p'],
        'p': ['o'], 'a': ['s'], 's': ['a', 'd'],
        'd': ['s', 'f'], 'f': ['d', 'g'], 'g': ['f', 'h'],
        'h': ['g', 'j'], 'j': ['h', 'k'], 'k': ['j', 'l'],
        'l': ['k'], 'z': ['x'], 'x': ['z', 'c'],
        'c': ['x', 'v'], 'v': ['c', 'b'], 'b': ['v', 'n'],
        'n': ['b', 'm'], 'm': ['n']
    };

    // --- DOM ELEMENTS & STATE ---
    const generateBtn = document.getElementById('generate-btn');
    const phraseOutput = document.getElementById('phrase-output');
    const copyBtn = document.getElementById('copy-btn');
    const toast = document.getElementById('toast');
    const safeModeToggle = document.getElementById('safe-mode-toggle');
    const safeModeSlider = document.getElementById('safe-mode-slider');
    let fillInterval;
    let currentFill = 0;
    const totalSteps = CONFIG.fillDuration / CONFIG.updateInterval; // Total number of steps
    let isComplete = false;
    let typingTimeouts = []; // Track active typing timeouts to prevent conflicts
    let isTyping = false; // Track if typing animation is currently active
    
    // Item timeout system - track recently used items to prevent repetition
    let itemTimeouts = {
        intro: new Map(), // Map of item -> remaining timeout count
        beast: new Map(),
        noun: new Map(),
        candy: new Map(),
        adjective: new Map(),
        finale: new Map(),
        tag: new Map()
    };

    // --- FUNCTIONS ---
    /**
     * Clears all active typing timeouts to prevent conflicts
     */
    const clearTypingTimeouts = () => {
      typingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
      typingTimeouts = [];
      isTyping = false;
    };

    /**
     * Adds an item to the timeout list with dynamic cooldown based on list size
     */
    const addItemToTimeout = (listType, item) => {
      const listTypes = ['intro', 'beast', 'noun', 'candy', 'adjective', 'finale', 'tag'];
      const listIndex = listTypes.indexOf(listType);
      
      if (listIndex !== -1 && window.wordLists && window.wordLists[listIndex]) {
        // Cooldown = total items in list - 1 (so it cycles through all items before repeating)
        const cooldownDuration = window.wordLists[listIndex].length - 1;
        itemTimeouts[listType].set(item, cooldownDuration);
      } else {
        // Fallback to a default if something goes wrong
        itemTimeouts[listType].set(item, 25);
      }
    };

    /**
     * Decrements all timeout counters and removes expired items
     */
    const decrementTimeouts = () => {
      Object.keys(itemTimeouts).forEach(listType => {
        const timeoutMap = itemTimeouts[listType];
        const itemsToRemove = [];
        
        timeoutMap.forEach((count, item) => {
          const newCount = count - 1;
          if (newCount <= 0) {
            itemsToRemove.push(item);
          } else {
            timeoutMap.set(item, newCount);
          }
        });
        
        itemsToRemove.forEach(item => timeoutMap.delete(item));
      });
    };

    /**
     * Gets available items from a list, excluding those on timeout
     */
    const getAvailableItems = (listIndex) => {
      const listTypes = ['intro', 'beast', 'noun', 'candy', 'adjective', 'finale', 'tag'];
      const listType = listTypes[listIndex];
      const allItems = window.wordLists[listIndex];
      const timeoutMap = itemTimeouts[listType];
      
      // Filter out items that are on timeout
      const availableItems = allItems.filter(item => !timeoutMap.has(item));
      
      // If all items are on timeout (shouldn't happen with 10 timeout and variety, but safety check)
      return availableItems.length > 0 ? availableItems : allItems;
    };

    /**
     * Applies letter swapping chaos to a phrase (respecting word boundaries)
     */
    const applyLetterSwapping = (phrase) => {
      if (Math.random() >= CONFIG.swapLettersChance) {
        return phrase; // No swapping this time
      }

      // Convert phrase to array for easier manipulation
      const chars = phrase.split('');
      
      // Find all eligible positions (not first/last letters of words, not spaces)
      const eligiblePositions = [];
      
      for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        if (char === ' ') continue; // Skip spaces
        
        // Check if this is first or last letter of a word
        const isFirstLetter = (i === 0 || chars[i - 1] === ' ');
        const isLastLetter = (i === chars.length - 1 || chars[i + 1] === ' ');
        
        if (!isFirstLetter && !isLastLetter) {
          eligiblePositions.push(i);
        }
      }
      
      // Need at least 2 eligible positions to swap
      if (eligiblePositions.length < 2) {
        return phrase; // Not enough letters to swap
      }
      
      // Pick two random eligible positions
      const pos1 = eligiblePositions[Math.floor(Math.random() * eligiblePositions.length)];
      let pos2;
      do {
        pos2 = eligiblePositions[Math.floor(Math.random() * eligiblePositions.length)];
      } while (pos2 === pos1);
      
      // Swap the characters
      const temp = chars[pos1];
      chars[pos1] = chars[pos2];
      chars[pos2] = temp;
      
      return chars.join('');
    };

    /**
     * Generates a random "weeeeee" with 4-10 'e's
     * @returns {string} A random weeeeee string
     */
    const generateWeeeeee = () => {
      const eCount = Math.floor(Math.random() * 7) + 4; // 4-10 'e's
      return 'we' + 'e'.repeat(eCount);
    };

    /**
     * Replaces NSFW words with appropriate alternatives if safe mode is enabled
     * @param {string} text The text to filter
     * @returns {string} The filtered text
     */
    const filterNSFW = (text) => {
      if (!CONFIG.safeMode) return text;
      
      let filteredText = text;
      
      // Replace 'fucking' specifically with 'freaking'
      filteredText = filteredText.replace(/\bfucking\b/gi, 'freaking');
      
      // Check other NSFW words and replace with weeeeee
      // Sort by length (longest first) to ensure compound words are processed before their components
      const sortedNsfwWords = window.nsfwWords
        .filter(word => word.toLowerCase() !== 'fucking') // Skip 'fucking' since we handled it above
        .sort((a, b) => b.length - a.length);
      
      sortedNsfwWords.forEach(nsfwWord => {
        // Create case-insensitive regex for the word
        const regex = new RegExp(`\\b${nsfwWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
        filteredText = filteredText.replace(regex, generateWeeeeee());
      });
      
      return filteredText;
    };

    /**
     * Selects a random item from a given array and processes brackets.
     * @param {Array} arr The array to pick from.
     * @returns {*} A random item from the array with brackets processed.
     */
    const getRandomItem = (arr) => {
      const rawItem = arr[Math.floor(Math.random() * arr.length)];
      const { result } = processBrackets(rawItem);
      return result;
    };

    /**
     * Creates a word tracking object for detailed format display
     */
    const createWordTracking = (original) => ({
        original,
        final: original,
        modifications: [],
        addons: [],
        alternates: [],
        hardStop: false,
        beastStop: false
    });

    /**
     * Processes alternates in a word (content in parentheses with / separators)
     */
    const processAlternates = (word) => {
        let result = word;
        let alternates = [];
        const alternatesRegex = /\(([^)]*(?:\/[^)]*)+)\)/g;
        let match;
        
        while ((match = alternatesRegex.exec(word)) !== null) {
            const alternatesContent = match[1];
            const options = alternatesContent.split('/').map(opt => opt.trim());
            
            // Check if any option has custom probability
            const hasCustomProbabilities = options.some(opt => opt.includes(',') && /,\s*\d*\.?\d+$/.test(opt));
            
            let selectedOption;
            if (hasCustomProbabilities) {
                // Parse options with probabilities
                const weightedOptions = [];
                options.forEach(opt => {
                    const probMatch = opt.match(/^(.+),\s*(\d*\.?\d+)$/);
                    if (probMatch) {
                        const content = probMatch[1].trim();
                        const weight = parseFloat(probMatch[2]);
                        weightedOptions.push({ content, weight });
                    } else {
                        weightedOptions.push({ content: opt, weight: 1 });
                    }
                });
                
                const totalWeight = weightedOptions.reduce((sum, opt) => sum + opt.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const opt of weightedOptions) {
                    random -= opt.weight;
                    if (random <= 0) {
                        selectedOption = opt.content;
                        break;
                    }
                }
            } else {
                const selectedIndex = Math.floor(Math.random() * options.length);
                selectedOption = options[selectedIndex];
                alternates.push(`alt: ${selectedOption}`);
            }
            
            result = result.replace(match[0], selectedOption);
        }
        
        return { result, alternates };
    };

    /**
     * Processes brackets (add-ons) in a word from innermost to outermost
     */
    const processBrackets = (word) => {
        let result = word;
        let addons = [];
        let hasHardStop = false;
        let hasBeastStop = false;
        
        // Check for *B* at the end of the main word (not in brackets)
        if (result.includes(', *B*') || result.endsWith(' *B*')) {
            hasBeastStop = true;
            // Remove the *B* marker from the result
            result = result.replace(/,\s*\*B\*|\s*\*B\*$/, '');
        }
        
        let changed = true;
        while (changed) {
            changed = false;
            
            // Find the innermost bracket (no brackets inside it)
            const innermostBracketRegex = /\[([^\[\]]+)\]/;
            const bracketMatch = result.match(innermostBracketRegex);
            
            if (bracketMatch) {
                const bracketContent = bracketMatch[1];
                
                // Check for custom probability
                const probabilityMatch = bracketContent.match(/^(.+),\s*(\d*\.?\d+)(?:,\s*\*F\*|\*B\*)?$/);
                let probability = 0.5;
                let contentToProcess = bracketContent;
                
                if (probabilityMatch) {
                    contentToProcess = probabilityMatch[1].trim();
                    probability = parseFloat(probabilityMatch[2]);
                } else {
                    // Check if it's just content with *F* or *B* (no probability)
                    const hardStopMatch = bracketContent.match(/^(.+),\s*\*F\*$/);
                    const beastStopMatch = bracketContent.match(/^(.+),\s*\*B\*$/);
                    if (hardStopMatch) {
                        contentToProcess = hardStopMatch[1].trim();
                        probability = 0.5; // default probability
                    } else if (beastStopMatch) {
                        contentToProcess = beastStopMatch[1].trim();
                        probability = 0.5; // default probability
                    }
                }
                
                const shouldInclude = Math.random() < probability;
                
                if (shouldInclude) {
                    // Clean the content before adding it to the result
                    let cleanContent = contentToProcess;
                    
                    // Remove hard stop marker (*F*) from the content
                    cleanContent = cleanContent.replace(/\*F\*/g, '');
                    
                    // Remove any remaining probability info that might be in the content
                    cleanContent = cleanContent.replace(/,\s*\d*\.?\d+\s*$/, '');
                    cleanContent = cleanContent.replace(/,\s*\d*\.?\d+\s*,/, ',');
                    
                    result = result.replace(bracketMatch[0], cleanContent);
                    
                    // Track the full bracket content including probability for display
                    addons.push(bracketContent);
                    
                    // Check for hard stop (*F*)
                    if (bracketContent.includes('*F*')) {
                        hasHardStop = true;
                    }
                    
                    // Check for beast stop (*B*)
                    if (bracketContent.includes('*B*')) {
                        hasBeastStop = true;
                    }
                } else {
                    result = result.replace(bracketMatch[0], '');
                }
                
                changed = true;
            }
        }
        
        return { result: result.replace(/\s+/g, ' ').trim(), addons, hasHardStop, hasBeastStop };
    };
    


    /**
     * Generates a new phrase and displays it.
     */
    const generateNewPhrase = () => {
        // Hide copy button while generating new phrase
        copyBtn.classList.add('opacity-0');
        
        // Clear any existing typing animations to prevent conflicts
        clearTypingTimeouts();
        
        // Define the possible formats (now using intro + word order)
        const formats = [
            (i, b, n, c, a, f) => `${i} ${b} ${n} ${f}`,
            (i, b, n, c, a, f) => `${i} ${n} ${c} ${f}`,
            (i, b, n, c, a, f) => `${i} ${b} ${n} ${f}`,
            (i, b, n, c, a, f) => `${i} ${a} ${b} ${n} ${f}`,
            (i, b, n, c, a, f) => `${i} ${n} ${c} ${f}`,
            (i, b, n, c, a, f) => `${i} ${b} ${c} ${n} ${f}`,
            (i, b, n, c, a, f) => `${i} ${b} ${a} ${f}`,
            (i, b, n, c, a, f) => `${i} ${b} ${c} ${n} ${f}`,
            (i, b, n, c, a, f) => `${i} ${b} ${c} ${f}`,
            (i, b, n, c, a, f) => `${i} ${b} ${a} ${n} ${f}`,
            (i, b, n, c, a, f) => `${i} ${b} ${a} ${c} ${f}`,
            (i, b, n, c, a, f) => `${i} ${n} ${a} ${c} ${f}`
        ];
        
        // Pick a random format
        const randomFormat = formats[Math.floor(Math.random() * formats.length)];
        const formatIndex = formats.indexOf(randomFormat);
        
        // Create a readable format string for logging
        const getFormatString = (format) => {
            const testResult = format('I', 'B', 'N', 'C', 'A', 'F');
            return testResult.replace(/I/g, 'I').replace(/B/g, 'B').replace(/N/g, 'N')
                            .replace(/C/g, 'C').replace(/A/g, 'A').replace(/F/g, 'F');
        };
        const formatString = getFormatString(randomFormat);
        
        // Determine which word types are needed for this format
        const needsIntro = formatString.includes('I');
        const needsBeast = formatString.includes('B');
        const needsNoun = formatString.includes('N');
        const needsCandy = formatString.includes('C');
        const needsAdjective = formatString.includes('A');
        const needsFinale = formatString.includes('F');
        
        // Only get random items for the word types we actually need
        const intro = needsIntro ? getAvailableItems(0)[Math.floor(Math.random() * getAvailableItems(0).length)] : null;
        const beast = needsBeast ? getAvailableItems(1)[Math.floor(Math.random() * getAvailableItems(1).length)] : null;
        const noun = needsNoun ? getAvailableItems(2)[Math.floor(Math.random() * getAvailableItems(2).length)] : null;
        const candy = needsCandy ? getAvailableItems(3)[Math.floor(Math.random() * getAvailableItems(3).length)] : null;
        const adjective = needsAdjective ? getAvailableItems(4)[Math.floor(Math.random() * getAvailableItems(4).length)] : null;
        const finale = needsFinale ? getAvailableItems(5)[Math.floor(Math.random() * getAvailableItems(5).length)] : null;
        
        // Track the actual words and their modifications for detailed display (only for needed types)
        const wordTracking = {
            intro: intro ? createWordTracking(intro) : null,
            beast: beast ? createWordTracking(beast) : null,
            noun: noun ? createWordTracking(noun) : null,
            candy: candy ? createWordTracking(candy) : null,
            adjective: adjective ? createWordTracking(adjective) : null,
            finale: finale ? createWordTracking(finale) : null
        };
        
        // Process each word with tracking
        const processWordWithTracking = (word, tracking) => {
            // Process alternates first
            const { result: afterAlternates, alternates } = processAlternates(word);
            
            // Process brackets
            const { result, addons, hasHardStop, hasBeastStop } = processBrackets(afterAlternates);
            
            // Update tracking
            tracking.final = result;
            tracking.addons = addons;
            tracking.alternates = alternates;
            tracking.hardStop = hasHardStop;
            tracking.beastStop = hasBeastStop;
            tracking.original = word; // Store original for display purposes
            
            // Hard stop handling will be done after all words are processed
            
            return result;
        };
        
        // Process each word (only the ones we need)
        let processedIntro = intro ? processWordWithTracking(intro, wordTracking.intro) : '';
        let processedBeast = beast ? processWordWithTracking(beast, wordTracking.beast) : '';
        let processedNoun = noun ? processWordWithTracking(noun, wordTracking.noun) : '';
        let processedCandy = candy ? processWordWithTracking(candy, wordTracking.candy) : '';
        let processedAdjective = adjective ? processWordWithTracking(adjective, wordTracking.adjective) : '';
        let processedFinale = finale ? processWordWithTracking(finale, wordTracking.finale) : '';
        
        // Initialize tag variables (will be set later if needed)
        let tag = null;
        let processedTag = '';
        let tagTracking = null;
        
        
        
        // Apply random duplications
        let finalBeast = processedBeast;
        let finalNoun = processedNoun;
        let finalCandy = processedCandy;
        
        // Track additional items used in this phrase for timeout system
        let additionalItemsUsed = [];
        
        // Track how many "fucking"s were added for logging
        let fucksGiven = 0;
        
        // Check for beast stop after first beast (only if beast is used)
        if (needsBeast && wordTracking.beast?.beastStop) {
            // Beast stop triggered by first beast - skip beast duplications
            // Continue with normal processing (noun, candy, adjective, finale)
        } else if (needsBeast && Math.random() < CONFIG.doubleBeastChance) {
            // Get a different beast (avoid duplicates and items on timeout)
            let availableSecondBeasts = getAvailableItems(1).filter(item => item !== beast);
            // If no available beasts (shouldn't happen), fall back to all beasts except the current one
            if (availableSecondBeasts.length === 0) {
                availableSecondBeasts = window.wordLists[1].filter(item => item !== beast);
            }
            const secondBeast = availableSecondBeasts[Math.floor(Math.random() * availableSecondBeasts.length)];
            additionalItemsUsed.push({type: 'beast', item: secondBeast});
            
            const secondBeastTracking = createWordTracking(secondBeast);
            const secondBeastProcessed = processWordWithTracking(secondBeast, secondBeastTracking);
            finalBeast = `${processedBeast} ${secondBeastProcessed}`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('double');
            // Merge add-ons from both beasts
            wordTracking.beast.addons = [...wordTracking.beast.addons, ...secondBeastTracking.addons];
            wordTracking.beast.alternates = [...wordTracking.beast.alternates, ...secondBeastTracking.alternates];
            
            // Check for beast stop after second beast
            if (wordTracking.beast.beastStop || secondBeastTracking.beastStop) {
                // Beast stop triggered by first or second beast - skip third beast
            } else if (Math.random() < CONFIG.tripleBeastChance) {
                // Get a different third beast (avoid duplicates with first two and items on timeout)
                let availableThirdBeasts = getAvailableItems(1).filter(item => item !== beast && item !== secondBeast);
                // If no available beasts (shouldn't happen), fall back to all beasts except the current ones
                if (availableThirdBeasts.length === 0) {
                    availableThirdBeasts = window.wordLists[1].filter(item => item !== beast && item !== secondBeast);
                }
                const thirdBeast = availableThirdBeasts[Math.floor(Math.random() * availableThirdBeasts.length)];
                additionalItemsUsed.push({type: 'beast', item: thirdBeast});
                
                const thirdBeastTracking = createWordTracking(thirdBeast);
                const thirdBeastProcessed = processWordWithTracking(thirdBeast, thirdBeastTracking);
                finalBeast = `${finalBeast} ${thirdBeastProcessed}`;
                wordTracking.beast.final = finalBeast;
                wordTracking.beast.modifications.push('triple');
                // Merge add-ons from third beast
                wordTracking.beast.addons = [...wordTracking.beast.addons, ...thirdBeastTracking.addons];
                wordTracking.beast.alternates = [...wordTracking.beast.alternates, ...thirdBeastTracking.alternates];
            }
        }

        // 5% chance to add a second candy (only if candy is used)
        if (needsCandy && Math.random() < CONFIG.doubleCandyChance) {
            // Get a different candy (avoid duplicates and items on timeout)
            let availableSecondCandies = getAvailableItems(3).filter(item => item !== candy);
            // If no available candies (shouldn't happen), fall back to all candies except the current one
            if (availableSecondCandies.length === 0) {
                availableSecondCandies = window.wordLists[3].filter(item => item !== candy);
            }
            const secondCandy = availableSecondCandies[Math.floor(Math.random() * availableSecondCandies.length)];
            additionalItemsUsed.push({type: 'candy', item: secondCandy});
            
            const secondCandyTracking = createWordTracking(secondCandy);
            const secondCandyProcessed = processWordWithTracking(secondCandy, secondCandyTracking);
            finalCandy = `${processedCandy} ${secondCandyProcessed}`;
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('double');
            // Merge add-ons from both candies
            wordTracking.candy.addons = [...wordTracking.candy.addons, ...secondCandyTracking.addons];
            wordTracking.candy.alternates = [...wordTracking.candy.alternates, ...secondCandyTracking.alternates];
        }
        
        // 10% chance to add "fucking" before beast (only if beast is used)
        if (needsBeast && Math.random() < CONFIG.fuckingChance) {
            finalBeast = `fucking ${finalBeast}`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('fucking');
            fucksGiven++;
        }
        
        // 10% chance to add "fucking" after the entire set of beasts (only if beast is used)
        if (needsBeast && Math.random() < 0.1) {
            finalBeast = `${finalBeast} fucking`;
            wordTracking.beast.final = finalBeast;
            wordTracking.beast.modifications.push('fucking-after');
            fucksGiven++;
        }
        
        // 10% chance to add "fucking" before noun (only if noun is used)
        if (needsNoun && Math.random() < CONFIG.fuckingChance) {
            finalNoun = `fucking ${finalNoun}`;
            wordTracking.noun.final = finalNoun;
            wordTracking.noun.modifications.push('fucking');
            fucksGiven++;
        }
        
        // 10% chance to add "fucking" before candy (only if candy is used)
        if (needsCandy && Math.random() < CONFIG.fuckingChance) {
            finalCandy = `fucking ${finalCandy}`;
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('fucking');
            fucksGiven++;
        }
        
        // Apply all caps to non-beast items (2% chance each, only if used)
        if (needsIntro && Math.random() < CONFIG.allCapsChance) {
            processedIntro = processedIntro.toUpperCase();
            wordTracking.intro.final = processedIntro;
            wordTracking.intro.modifications.push('all-caps');
        }
        
        if (needsNoun && Math.random() < CONFIG.allCapsChance) {
            finalNoun = finalNoun.toUpperCase();
            wordTracking.noun.final = finalNoun;
            wordTracking.noun.modifications.push('all-caps');
        }
        
        if (needsCandy && Math.random() < CONFIG.allCapsChance) {
            finalCandy = finalCandy.toUpperCase();
            wordTracking.candy.final = finalCandy;
            wordTracking.candy.modifications.push('all-caps');
        }
        
        if (needsAdjective && Math.random() < CONFIG.allCapsChance) {
            processedAdjective = processedAdjective.toUpperCase();
            wordTracking.adjective.final = processedAdjective;
            wordTracking.adjective.modifications.push('all-caps');
        }
        
        if (needsFinale && Math.random() < CONFIG.allCapsChance) {
            processedFinale = processedFinale.toUpperCase();
            wordTracking.finale.final = processedFinale;
            wordTracking.finale.modifications.push('all-caps');
        }
        
        // Check for hard stops before generating phrase
        let hasHardStop = false;
        let hardStopWord = '';
        
        // Combined debug output (only show word types that were actually used)
        // Create words object in the desired order: intro, beast, noun, candy, adjective, finale, tag
        const wordsInOrder = {};
        
        // Add words in the specific order, only if they were used
        if (needsIntro) {
            let introDisplay = processedIntro;
            if (wordTracking.intro?.hardStop) introDisplay += ', *F*';
            if (wordTracking.intro?.beastStop) introDisplay += ', *B*';
            wordsInOrder.intro = introDisplay;
        }
        if (needsBeast) {
            let beastDisplay = finalBeast;
            if (wordTracking.beast?.hardStop) beastDisplay += ', *F*';
            if (wordTracking.beast?.beastStop) beastDisplay += ', *B*';
            wordsInOrder.beast = beastDisplay;
        }
        if (needsNoun) {
            let nounDisplay = finalNoun;
            if (wordTracking.noun?.hardStop) nounDisplay += ', *F*';
            if (wordTracking.noun?.beastStop) nounDisplay += ', *B*';
            wordsInOrder.noun = nounDisplay;
        }
        if (needsCandy) {
            let candyDisplay = finalCandy;
            if (wordTracking.candy?.hardStop) candyDisplay += ', *F*';
            if (wordTracking.candy?.beastStop) candyDisplay += ', *B*';
            wordsInOrder.candy = candyDisplay;
        }
        if (needsAdjective) {
            let adjectiveDisplay = processedAdjective;
            if (wordTracking.adjective?.hardStop) adjectiveDisplay += ', *F*';
            if (wordTracking.adjective?.beastStop) adjectiveDisplay += ', *B*';
            wordsInOrder.adjective = adjectiveDisplay;
        }
        if (needsFinale) {
            let finaleDisplay = processedFinale;
            if (wordTracking.finale?.hardStop) finaleDisplay += ', *F*';
            if (wordTracking.finale?.beastStop) finaleDisplay += ', *B*';
            wordsInOrder.finale = finaleDisplay;
        }
        
        const debugOutput = {
            format: `${formatIndex + 1} (${formatString})`,
            fucksGiven: fucksGiven,
            words: wordsInOrder
        };
        
        // Check each word type for hard stops (only the ones that were processed)
        if (needsIntro && wordTracking.intro?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedIntro;
        } else if (needsBeast && wordTracking.beast?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalBeast;
        } else if (needsNoun && wordTracking.noun?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalNoun;
        } else if (needsCandy && wordTracking.candy?.hardStop) {
            hasHardStop = true;
            hardStopWord = finalCandy;
        } else if (needsAdjective && wordTracking.adjective?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedAdjective;
        } else if (needsFinale && wordTracking.finale?.hardStop) {
            hasHardStop = true;
            hardStopWord = processedFinale;
        }
        
        // Generate phrase using the selected format with modified words
        let phrase;
        if (hasHardStop) {
            // If there's a hard stop, generate the phrase up to that point
            // We need to determine which word type triggered the hard stop and build the phrase accordingly
            if (needsIntro && wordTracking.intro?.hardStop) {
                phrase = processedIntro;
            } else if (needsBeast && wordTracking.beast?.hardStop) {
                phrase = randomFormat(processedIntro, finalBeast, '', '', '', '');
            } else if (needsNoun && wordTracking.noun?.hardStop) {
                phrase = randomFormat(processedIntro, finalBeast, finalNoun, '', '', '');
            } else if (needsCandy && wordTracking.candy?.hardStop) {
                phrase = randomFormat(processedIntro, finalBeast, finalNoun, finalCandy, '', '');
            } else if (needsAdjective && wordTracking.adjective?.hardStop) {
                phrase = randomFormat(processedIntro, finalBeast, finalNoun, finalCandy, processedAdjective, '');
            } else if (needsFinale && wordTracking.finale?.hardStop) {
                phrase = randomFormat(processedIntro, finalBeast, finalNoun, finalCandy, processedAdjective, processedFinale);
            }
        } else {
            // Normal phrase generation
            phrase = randomFormat(processedIntro, finalBeast, finalNoun, finalCandy, processedAdjective, processedFinale);
        }
        
        // Clean up any double "fucking" in a row
        phrase = phrase.replace(/\bfucking\s+fucking\b/g, 'fucking');
        
        // Remove hard stop markers (*F*) and beast stop markers (*B*) from final phrase
        phrase = phrase.replace(/\*F\*/g, '');
        phrase = phrase.replace(/\*B\*/g, '');
        
        // Apply safe mode filtering if enabled
        phrase = filterNSFW(phrase);
        
        // Apply letter swapping chaos (0.5% chance)
        phrase = applyLetterSwapping(phrase);
        
        // Check for tag addition (10% chance after finale or hard stop)
        // Tags appear after finales (normal completion) or hard stops
        const shouldAddTag = (needsFinale || hasHardStop) && Math.random() < CONFIG.tagChance;
        
        if (shouldAddTag) {
            // Get a random tag from available tags
            const availableTags = getAvailableItems(6); // Tags are at index 6
            if (availableTags.length > 0) {
                tag = availableTags[Math.floor(Math.random() * availableTags.length)];
                tagTracking = createWordTracking(tag);
                
                // Process the tag word
                const processWordWithTracking = (word, tracking) => {
                    // Process alternates first
                    const { result: afterAlternates, alternates } = processAlternates(word);
                    
                    // Process brackets
                    const { result, addons, hasHardStop, hasBeastStop } = processBrackets(afterAlternates);
                    
                    // Update tracking
                    tracking.final = result;
                    tracking.addons = addons;
                    tracking.alternates = alternates;
                    tracking.hardStop = hasHardStop;
                    tracking.beastStop = hasBeastStop;
                    tracking.original = word;
                    
                    return result;
                };
                
                processedTag = processWordWithTracking(tag, tagTracking);
                
                // Add the tag to the end of the phrase
                phrase = `${phrase} ${processedTag}`;
                
                // Add tag to debug output
                let tagDisplay = processedTag;
                if (tagTracking?.hardStop) tagDisplay += ', *F*';
                if (tagTracking?.beastStop) tagDisplay += ', *B*';
                debugOutput.words.tag = tagDisplay;
            }
        }
        
        // Log debug output after all processing is complete
        console.log('ðŸŽª Joy Machine Debug:', debugOutput);
        
        // Add used items to timeout list to prevent repetition (only the ones that were actually used)
        if (needsIntro && intro) addItemToTimeout('intro', intro);
        if (needsBeast && beast) addItemToTimeout('beast', beast);
        if (needsNoun && noun) addItemToTimeout('noun', noun);
        if (needsCandy && candy) addItemToTimeout('candy', candy);
        if (needsAdjective && adjective) addItemToTimeout('adjective', adjective);
        if (needsFinale && finale) addItemToTimeout('finale', finale);
        if (tag) addItemToTimeout('tag', tag);
        
        // Add additional beasts and candies that were used
        additionalItemsUsed.forEach(({type, item}) => {
            addItemToTimeout(type, item);
        });
        
        // Decrement all timeout counters for next phrase
        decrementTimeouts();
        
        // Animate typing the phrase
        typeOutPhrase(phrase);
        
        // Generate detailed format display
        // const formatDisplay = document.getElementById('format-display');
        // if (formatDisplay) {
        //     const detailedFormat = generateDetailedFormatString(phrase, randomFormat, wordTracking, formatIndex + 1);
        //     formatDisplay.textContent = `Format ${formatIndex + 1}: ${detailedFormat}`;
        // }
        
        // Copy button will be shown after typing animation completes
    };
    
    // Helper function to generate detailed format string with inline annotations
    const generateDetailedFormatString = (phrase, format, wordTracking, formatNumber) => {
        // Create a test phrase to determine the format structure
        const testPhrase = format('I', 'B', 'N', 'C', 'A', 'F');
        const testParts = testPhrase.split(' ');
        
        // Map test parts to their types
        const typeMap = {};
        testParts.forEach((part, index) => {
            if (part === 'I') typeMap[index] = 'I';
            else if (part === 'B') typeMap[index] = 'B';
            else if (part === 'N') typeMap[index] = 'N';
            else if (part === 'C') typeMap[index] = 'C';
            else if (part === 'A') typeMap[index] = 'A';
            else if (part === 'F') typeMap[index] = 'F';
        });
        
        let result = [];
        let literalWords = [];
        
        // Process each part of the test phrase
        testParts.forEach((testPart, testIndex) => {
            if (testPart === 'I' || testPart === 'B' || testPart === 'N' || testPart === 'C' || testPart === 'A' || testPart === 'F') {
                // This is a variable position - first flush any accumulated literal words
                if (literalWords.length > 0) {
                    result.push(`"${literalWords.join(' ')}"`);
                    literalWords = [];
                }
                
                const type = typeMap[testIndex];
                const wordData = wordTracking[type === 'I' ? 'intro' : type === 'B' ? 'beast' : type === 'N' ? 'noun' : type === 'C' ? 'candy' : type === 'A' ? 'adjective' : 'finale'];
                
                // Use the final processed word, not the original
                let displayWord = wordData.final;
                
                // Add quotes around "fucking" if it was added (before or after)
                if (wordData.modifications.includes('fucking')) {
                    displayWord = displayWord.replace(/^fucking /, '"fucking" ');
                }
                if (wordData.modifications.includes('fucking-after')) {
                    displayWord = displayWord.replace(/ fucking$/, ' "fucking"');
                }
                
                // Remove hard stop markers (*F*) and beast stop markers (*B*) from display
                displayWord = displayWord.replace(/\*F\*/g, '');
                displayWord = displayWord.replace(/\*B\*/g, '');
                
                // Add back brackets for add-ons that were actually included
                if (wordData.addons.length > 0) {
                    wordData.addons.forEach(addon => {
                        const cleanAddon = addon.replace(/,\s*\d*\.?\d+$/, '');
                        // Find where this addon content appears in the final word and wrap it in brackets
                        if (wordData.final.includes(cleanAddon)) {
                            displayWord = displayWord.replace(cleanAddon, `[${cleanAddon}]`);
                        }
                    });
                }
                
                // Add back alternates for alternates that were actually selected
                if (wordData.alternates.length > 0) {
                    wordData.alternates.forEach(alt => {
                        const cleanAlt = alt.replace('alt: ', '');
                        // Find where this alternate content appears in the final word and wrap it in parentheses
                        if (wordData.final.includes(cleanAlt)) {
                            displayWord = displayWord.replace(cleanAlt, `(${cleanAlt})`);
                        }
                    });
                }
                
                // Add the processed word as a single unit
                result.push(displayWord);
                
                // Add type annotation after brackets
                result[result.length - 1] += ` (${type})`;
                
                // Add hard stop marker if this word triggered a hard stop
                if (wordData.hardStop) {
                    result[result.length - 1] += ' *F*';
                }
                
                // Add beast stop marker if this word triggered a beast stop
                if (wordData.beastStop) {
                    result[result.length - 1] += ' *B*';
                }
                
                // Add modification annotations
                if (wordData.modifications.includes('triple')) {
                    result[result.length - 1] += ' (3)';
                } else if (wordData.modifications.includes('double')) {
                    result[result.length - 1] += ' (2)';
                }
            } else {
                // This is literal text - accumulate it
                literalWords.push(testPart);
            }
        });
        
        // Flush any remaining literal words
        if (literalWords.length > 0) {
            result.push(`"${literalWords.join(' ')}"`);
        }
        
        return result.join(' ');
    };
    
    /**
     * Updates button state classes and text
     */
    const updateButtonState = (state) => {
      generateBtn.classList.remove('filling', 'ready');
      generateBtn.classList.add(state);
      
      // Update button text based on state
      const btnText = generateBtn.querySelector('.btn-text');
      if (state === 'filling') {
        btnText.textContent = '';
      } else if (state === 'ready') {
        btnText.textContent = 'GO';
      }
    };

    /**
     * Updates safe mode toggle appearance
     */
    const updateSafeModeToggle = () => {
      if (CONFIG.safeMode) {
        safeModeToggle.classList.add('bg-blue-500');
        safeModeToggle.classList.remove('bg-gray-200');
        safeModeSlider.classList.add('translate-x-5');
        safeModeSlider.classList.remove('translate-x-0');
      } else {
        safeModeToggle.classList.remove('bg-blue-500');
        safeModeToggle.classList.add('bg-gray-200');
        safeModeSlider.classList.remove('translate-x-5');
        safeModeSlider.classList.add('translate-x-0');
      }
    };


    /**
     * Toggles safe mode on/off
     */
    const toggleSafeMode = () => {
      CONFIG.safeMode = !CONFIG.safeMode;
      updateSafeModeToggle();
    };
    
    /**
     * Shows toast notification
     */
    const showToast = () => {
      toast.classList.remove('opacity-0');
      setTimeout(() => {
        toast.classList.add('opacity-0');
      }, 2000);
    };
    
    /**
     * Animate typing out a phrase with realistic human-like patterns including typo correction
     */
    const typeOutPhrase = (phrase) => {
        // Safety check - ensure phrase is defined
        if (!phrase || typeof phrase !== 'string') {
            console.error('typeOutPhrase called with invalid phrase:', phrase);
            return;
        }
        
        // Clear any existing typing animations to prevent conflicts
        clearTypingTimeouts();
        
        // Clear the phrase output first
        phraseOutput.textContent = '';
        
        // Mark typing as active
        isTyping = true;
        
        let currentIndex = 0;
        let typingSpeed = 1.0; // Dynamic speed multiplier
        let lastCharTime = 0;
        let pendingCorrections = []; // Track typos that need correction
        let displayedText = ''; // Track what's actually displayed
        let hasActiveTypo = false; // Prevent multiple typos
        
        const typeNextChar = () => {
            if (currentIndex < phrase.length) {
                const char = phrase[currentIndex];
                const prevChar = currentIndex > 0 ? phrase[currentIndex - 1] : '';
                
                // Check for various random effects
                let actualChar = char;
                let shouldSkip = false;
                let shouldDouble = false;
                
                // 1% chance to skip spaces between words
                if (char === ' ' && Math.random() < CONFIG.skipSpaceChance) {
                    shouldSkip = true;
                }
                
                // Check if this is the first or last letter of a word (immune to skipping/doubling)
                let isFirstLetterOfWord = false;
                let isLastLetterOfWord = false;
                
                if (char !== ' ') {
                    // Check if previous char is space or start of phrase (first letter of word)
                    isFirstLetterOfWord = (currentIndex === 0 || phrase[currentIndex - 1] === ' ');
                    
                    // Check if next char is space or end of phrase (last letter of word)
                    isLastLetterOfWord = (currentIndex === phrase.length - 1 || phrase[currentIndex + 1] === ' ');
                }
                
                // .5% chance to skip letters in words (not spaces, not first/last letters)
                if (char !== ' ' && !isFirstLetterOfWord && !isLastLetterOfWord && Math.random() < CONFIG.skipLetterChance) {
                    shouldSkip = true;
                }
                
                // .2% chance to double letters in words (not spaces, not first/last letters)
                if (char !== ' ' && !isFirstLetterOfWord && !isLastLetterOfWord && Math.random() < CONFIG.doubleLetterChance) {
                    shouldDouble = true;
                }
                
                // Check if we should introduce a typo (1% chance per letter, but only if no active typo and not skipping)
                let shouldMakeTypo = !shouldSkip && !hasActiveTypo && Math.random() < CONFIG.typoChance && char.match(/[a-zA-Z]/);
                
                if (shouldMakeTypo) {
                    // Make a typo based on QWERTY keyboard layout
                    actualChar = getTypoChar(char);
                    hasActiveTypo = true; // Prevent more typos
                }
                
                // Apply the effects
                if (shouldSkip) {
                    // Skip this character entirely - don't add to displayedText
                } else if (shouldDouble) {
                    // Add the character twice
                    displayedText += actualChar + actualChar;
                } else {
                    // Add the character normally (could be original or typo)
                    displayedText += actualChar;
                }
                
                phraseOutput.textContent = displayedText;
                currentIndex++;
                
                // Check if we're at the end of a word (space or end of phrase)
                const isEndOfWord = char === ' ' || currentIndex >= phrase.length;
                
                if (isEndOfWord && hasActiveTypo) {
                    // We've finished typing a word that had a typo - check if we should correct it
                    // Calculate correction chance based on typo position
                    let correctionChance = CONFIG.typoCorrectionChance; // Default 80%
                    
                    // Find the start of the current word in the phrase
                    let wordStartIndex = currentIndex - 1;
                    while (wordStartIndex > 0 && phrase[wordStartIndex - 1] !== ' ') {
                        wordStartIndex--;
                    }
                    
                    // Find the start of the current word in displayed text
                    let displayedWordStartIndex = displayedText.length - 1;
                    while (displayedWordStartIndex > 0 && displayedText[displayedWordStartIndex - 1] !== ' ') {
                        displayedWordStartIndex--;
                    }
                    
                    // Get the displayed word (what we actually typed)
                    const displayedWord = displayedText.substring(displayedWordStartIndex).trim();
                    
                    // Get the correct word from the original phrase
                    const correctWord = phrase.substring(wordStartIndex, currentIndex).trim();
                    
                    // Find the first character that differs
                    let typoPosition = 0;
                    while (typoPosition < Math.min(displayedWord.length, correctWord.length) && 
                           displayedWord[typoPosition] === correctWord[typoPosition]) {
                        typoPosition++;
                    }
                    
                    // Adjust correction chance based on typo position
                    if (typoPosition === 0) {
                        correctionChance = 1.0; // 100% chance for first letter
                    } else if (typoPosition > 0 && typoPosition < displayedWord.length - 1) {
                        correctionChance = 0.65; // 65% chance for middle letters
                    }
                    // Last letter keeps the default 80% chance
                    
                    if (Math.random() < correctionChance) {
                        // Compare and correct if different
                        if (correctWord !== displayedWord) {
                            correctWordTypo(wordStartIndex, correctWord, displayedWordStartIndex);
                            return; // Don't continue until correction is done
                        }
                    }
                    
                    // Reset typo flag for next word
                    hasActiveTypo = false;
                }
                
                // Calculate realistic delay based on multiple factors
                let baseDelay;
                
                if (CONFIG.testMode) {
                    // Test mode: super fast typing (1-3ms per character)
                    baseDelay = 1 + Math.random() * 2;
                } else {
                    // Normal mode: realistic human typing
                    baseDelay = getBaseDelay(actualChar, prevChar);
                    
                    // Apply dynamic speed variation (human rhythm changes)
                    typingSpeed += (Math.random() - 0.5) * 0.1; // Gradual speed changes
                    typingSpeed = Math.max(0.3, Math.min(1.8, typingSpeed)); // Clamp between 0.3x and 1.8x
                    baseDelay *= typingSpeed;
                    
                    // Add natural rhythm variations
                    const rhythmVariation = 0.5 + Math.random() * 1.0; // 0.5x to 1.5x variation
                    baseDelay *= rhythmVariation;
                }
                
                if (!CONFIG.testMode) {
                    // Normal mode: apply all the realistic human typing effects
                    
                    // Simulate typing bursts (fast sequences followed by pauses)
                    const timeSinceLastChar = Date.now() - lastCharTime;
                    if (timeSinceLastChar > 200) { // After a pause, start with slower typing
                        baseDelay *= 1.5;
                    }
                    
                    // Natural pauses after punctuation
                    if (prevChar.match(/[.!?]/)) {
                        baseDelay += 33.33 + Math.random() * 66.67; // Extra pause after sentences (3/4ths slower)
                    } else if (prevChar.match(/[,;:]/)) {
                        baseDelay += 13.33 + Math.random() * 33.33; // Shorter pause after commas (3/4ths slower)
                    }
                    
                    // Occasional longer thinking pauses (more frequent than before)
                    if (Math.random() < CONFIG.thinkingPauseChance) { // 8% chance
                        baseDelay += 66.67 + Math.random() * 133.33; // Longer thinking pause (3/4ths slower)
                    }
                    
                    // Simulate finger fatigue (gradually slower over time)
                    const fatigueFactor = 1 + (currentIndex / phrase.length) * 0.05; // Up to 5% slower
                    baseDelay *= fatigueFactor;
                    
                    // Word boundaries get slight pauses
                    if (char === ' ') {
                        baseDelay += 6.67 + Math.random() * 13.33; // 3/4ths slower
                    }
                }
                
                lastCharTime = Date.now();
                
                // Schedule next character
                const timeoutId = setTimeout(typeNextChar, Math.round(baseDelay));
                typingTimeouts.push(timeoutId);
            } else {
                // Typing complete - show copy button and mark typing as inactive
                copyBtn.classList.remove('opacity-0');
                isTyping = false;
                typingTimeouts = []; // Clear the timeout array since we're done
            }
        };
        
        // Function to correct a word typo by comparing and fixing
        const correctWordTypo = (wordStartIndex, correctWord, displayedWordStartIndex) => {
            // Get the current displayed word
            const displayedWord = displayedText.substring(displayedWordStartIndex).trim();
            
            // Find the first character that differs
            let typoPosition = 0;
            while (typoPosition < Math.min(displayedWord.length, correctWord.length) && 
                   displayedWord[typoPosition] === correctWord[typoPosition]) {
                typoPosition++;
            }
            
            // If no difference found, something went wrong - just continue
            if (typoPosition >= displayedWord.length && displayedWord.length === correctWord.length) {
                hasActiveTypo = false;
                typeNextChar();
                return;
            }
            
            // Debug logging
            console.log('Typo correction:', {
                displayedWord,
                correctWord,
                typoPosition,
                wordStartIndex
            });
            
            // Calculate how many characters to backspace (from end of word to typo position, including the typo)
            const charsToBackspace = displayedWord.length - typoPosition + 1;
            let backspaceCount = 0;
            
            const backspace = () => {
                if (backspaceCount < charsToBackspace) {
                    displayedText = displayedText.substring(0, displayedText.length - 1);
                    phraseOutput.textContent = displayedText;
                    backspaceCount++;
                    
                    // Calculate backspace delay
                    let delay;
                    if (CONFIG.testMode) {
                        delay = 1; // Super fast backspacing in test mode
                    } else {
                        // Slow down as we approach the typo (start fast, end slow)
                        const progress = backspaceCount / charsToBackspace; // 0 to 1
                        const speedMultiplier = 1 + (progress * 3); // 1x to 4x slower
                        const baseDelay = 15 + Math.random() * 25; // Original fast delay
                        delay = baseDelay * speedMultiplier; // Apply slowdown
                    }
                    
                    const timeoutId = setTimeout(backspace, delay);
                    typingTimeouts.push(timeoutId);
                } else {
                    // Now continue typing from the typo position
                    continueTypingFromWordTypo(wordStartIndex + typoPosition);
                }
            };
            
            backspace();
        };
        
        // Function to continue typing from a word typo position
        const continueTypingFromWordTypo = (phrasePosition) => {
            // Update currentIndex to match where we are in the original phrase
            currentIndex = phrasePosition;
            
            // Reset typo flag and continue normal typing
            hasActiveTypo = false;
            typeNextChar();
        };
        
        // Function to continue typing from the typo position
        const continueTypingFromTypo = (typoIndex) => {
            // Update currentIndex to match where we are in the original phrase
            currentIndex = typoIndex;
            
            // Reset typo flag and continue normal typing
            hasActiveTypo = false;
            typeNextChar();
        };
        
        // Function to retype a word correctly (kept for compatibility)
        const retypeWord = (wordStartIndex, wordEndIndex) => {
            let retypeIndex = wordStartIndex;
            const retype = () => {
                if (retypeIndex < wordEndIndex) {
                    const char = phrase[retypeIndex];
                    displayedText += char;
                    phraseOutput.textContent = displayedText;
                    retypeIndex++;
                    const retypeDelay = CONFIG.testMode ? 1 : (15 + Math.random() * 25); // Super fast in test mode
                    const timeoutId = setTimeout(retype, retypeDelay);
                    typingTimeouts.push(timeoutId);
                } else {
                    // Word retyped correctly
                    
                    // Remove this correction from pending list
                    const correctionIndex = pendingCorrections.findIndex(c => c.typoIndex === wordStartIndex);
                    if (correctionIndex !== -1) {
                        pendingCorrections.splice(correctionIndex, 1);
                    }
                    
                    // Reset the active typo flag
                    hasActiveTypo = false;
                    
                    // Continue typing from where we left off in the original phrase
                    const continueDelay = CONFIG.testMode ? 1 : (25 + Math.random() * 50); // Super fast in test mode
                    const timeoutId = setTimeout(typeNextChar, continueDelay);
                    typingTimeouts.push(timeoutId);
                }
            };
            
            retype();
        };
        
        // Helper function to get a typo character based on QWERTY layout
        const getTypoChar = (char) => {
            const lowerChar = char.toLowerCase();
            if (QWERTY_MAP[lowerChar]) {
                const typoOptions = QWERTY_MAP[lowerChar];
                const selectedTypo = typoOptions[Math.floor(Math.random() * typoOptions.length)];
                return char === char.toUpperCase() ? selectedTypo.toUpperCase() : selectedTypo;
            }
            return char; // No typo possible, return original
        };
        
        // Helper function to get base delay for character types
        const getBaseDelay = (char, prevChar) => {
            if (char === ' ') {
                return CONFIG.typingSpeed.space.min + Math.random() * (CONFIG.typingSpeed.space.max - CONFIG.typingSpeed.space.min);
            } else if (char.match(/[a-zA-Z]/)) {
                // Vowels are typically typed faster than consonants
                if (char.match(/[aeiouAEIOU]/)) {
                    return CONFIG.typingSpeed.vowel.min + Math.random() * (CONFIG.typingSpeed.vowel.max - CONFIG.typingSpeed.vowel.min);
                } else {
                    return CONFIG.typingSpeed.consonant.min + Math.random() * (CONFIG.typingSpeed.consonant.max - CONFIG.typingSpeed.consonant.min);
                }
            } else if (char.match(/[0-9]/)) {
                return CONFIG.typingSpeed.number.min + Math.random() * (CONFIG.typingSpeed.number.max - CONFIG.typingSpeed.number.min);
            } else {
                return CONFIG.typingSpeed.punctuation.min + Math.random() * (CONFIG.typingSpeed.punctuation.max - CONFIG.typingSpeed.punctuation.min);
            }
        };
        
        // Start typing
        lastCharTime = Date.now();
        typeNextChar();
    };


    /**
     * Copies phrase to clipboard
     */
    const copyToClipboard = async () => {
      try {
        await navigator.clipboard.writeText(phraseOutput.textContent);
        showToast();
      } catch (err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = phraseOutput.textContent;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showToast();
      }
    };
    
    /**
     * Starts the auto-fill animation
     */
    const startAutoFill = () => {
      if (isComplete) return; // Don't restart if already complete
      
      currentFill = 0;
      // Temporarily disable transition for instant reset
      generateBtn.style.setProperty('--fill-width', '0%');
      updateButtonState('filling');
      
      // Test mode: instantly complete the bar
      if (CONFIG.testMode) {
        currentFill = totalSteps;
        generateBtn.style.setProperty('--fill-width', '100%');
        updateButtonState('ready');
        isComplete = true;
        return;
      }
      
      // Normal mode: gradual fill
      fillInterval = setInterval(() => {
        currentFill++;
        const fillPercentage = (currentFill / totalSteps) * 100;
        generateBtn.style.setProperty('--fill-width', `${fillPercentage}%`);
        
        // When the button is full, mark as ready (no phrase generation yet)
        if (currentFill >= totalSteps) {
          clearInterval(fillInterval);
          updateButtonState('ready');
            isComplete = true;
        }
      }, CONFIG.updateInterval);
    };

    // --- EVENT LISTENERS ---
    // Copy button functionality
    copyBtn.addEventListener('click', copyToClipboard);
    
    // Safe mode toggle functionality
    safeModeToggle.addEventListener('click', toggleSafeMode);
    
    // Function to advance progress bar
    const advanceProgress = () => {
      if (!isComplete) {
        // Advance the fill by 1%
        const advanceAmount = totalSteps * CONFIG.advanceAmount; // 1% of total steps
        currentFill = Math.min(currentFill + advanceAmount, totalSteps);
        
        const fillPercentage = (currentFill / totalSteps) * 100;
        generateBtn.style.setProperty('--fill-width', `${fillPercentage}%`);
        
        // Check if we've reached completion
        if (currentFill >= totalSteps) {
          clearInterval(fillInterval);
          updateButtonState('ready');
          isComplete = true;
        }
      }
    };

    // Add click functionality to advance loading by 1% or restart when ready
    generateBtn.addEventListener('click', (event) => {
      if (!isComplete) {
        // Advance progress when button is clicked during filling
        advanceProgress();
      } else {
        // Button is ready - generate new phrase and restart
        generateNewPhrase();
        isComplete = false;
        
        // Remove ready class first to disable transition
        generateBtn.classList.remove('ready');
        generateBtn.style.setProperty('--fill-width', '0%');
        
        // Force a reflow
        generateBtn.offsetHeight;
        
        startAutoFill();
      }
    });

    // Add document-level click listener to advance progress from anywhere on screen
    document.addEventListener('click', (event) => {
      // Only advance progress if we're not complete and not clicking on the generate button
      // (to avoid double advancement when clicking the button)
      if (!isComplete && event.target !== generateBtn && !generateBtn.contains(event.target)) {
        advanceProgress();
      }
    });

    // --- AUDIO FUNCTIONS ---
    const backgroundMusic = document.getElementById('background-music');
    
    /**
     * Initializes background music
     */
    const initializeAudio = () => {
      if (!CONFIG.backgroundMusic) return;
      
      backgroundMusic.volume = CONFIG.musicVolume;
      
      // Try to play music on first user interaction
      const startMusic = () => {
        if (CONFIG.backgroundMusic) {
          backgroundMusic.play().catch(e => {
            console.log('Audio autoplay prevented by browser policy. Music will start on user interaction.');
          });
        }
        // Remove the event listeners after first interaction
        document.removeEventListener('click', startMusic);
        document.removeEventListener('keydown', startMusic);
      };
      
      // Add event listeners for first user interaction
      document.addEventListener('click', startMusic);
      document.addEventListener('keydown', startMusic);
    };
    
    /**
     * Toggles background music on/off
     */
    const toggleMusic = () => {
      if (backgroundMusic.paused) {
        backgroundMusic.play();
      } else {
        backgroundMusic.pause();
      }
    };

    // --- INITIALIZATION ---
    // Initialize safe mode toggle
    updateSafeModeToggle();
    
    // Initialize background music
    initializeAudio();
    
    // Start the auto-fill animation when the page loads
    startAutoFill();

  </script>

</body>
</html>